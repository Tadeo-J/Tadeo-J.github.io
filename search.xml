<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ZYNQ Study</title>
      <link href="/2024/04/23/ZYNQ/"/>
      <url>/2024/04/23/ZYNQ/</url>
      
        <content type="html"><![CDATA[<h1 id="ZYNQ学习"><a href="#ZYNQ学习" class="headerlink" title="ZYNQ学习"></a>ZYNQ学习</h1><h2 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h2><img src="/images/ZYNQ/image-20240425144028448.png" alt="image-20240425144028448" style="zoom: 80%;" /><h3 id="EMIO"><a href="#EMIO" class="headerlink" title="EMIO"></a>EMIO</h3><p>（1）什么是EMIO?</p><ul><li>PS与PL端之间的接口，EMIO是扩展的MIO，当PS端的引脚不够用的时候，可以通过EMIO进行扩展，使用PL端的引脚</li></ul><p>（2）如何使用MIO的输入？</p><ul><li>XGpioPs_SetDirectionPin(&amp;gpiops_inst, MIO_KEY, 0); 直接设置为0即可</li></ul><h3 id="GPIO中断"><a href="#GPIO中断" class="headerlink" title="GPIO中断"></a>GPIO中断</h3><p>（1）中断控制器怎么确定是哪个引脚的中断？</p><ul><li>判断INT_MASK，如果某个引脚的该寄存器被屏蔽，即该引脚没有产生中断</li><li>判断INT_STAT，如果两个引脚的INT_MASK都没有被屏蔽，就判断INT_STAT，某个引脚该寄存器拉高，即该引脚产生中断</li></ul><p>（2）中断配置代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SetupInterruptSystem</span><span class="params">(XScuGic *GicInstancePtr, XGpioPs *Gpio, u16 GpioIntrId)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 查找中断控制器的配置信息</span></span><br><span class="line">IntcConfig = XScuGic_LookupConfig(INTC_DEVICE_ID);</span><br><span class="line"><span class="comment">// 初始化中断控制器</span></span><br><span class="line">XScuGic_CfgInitialize(GicInstancePtr, IntcConfig, IntcConfig-&gt;CpuBaseAddress);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化ARM处理器异常句柄</span></span><br><span class="line">Xil_ExceptionInit();</span><br><span class="line"><span class="comment">// IRQ异常注册处理程序</span></span><br><span class="line">Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT, (Xil_ExceptionHandler)XScuGic_InterruptHandler, GicInstancePtr);</span><br><span class="line"><span class="comment">// 为GPIO器件使能中断，打开中断控制器的使能（GIC）</span></span><br><span class="line">XScuGic_Enable(GicInstancePtr, GpioIntrId);</span><br><span class="line"><span class="comment">// 使能处理器的中断</span></span><br><span class="line">Xil_ExceptionEnableMask();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关联中断处理函数</span></span><br><span class="line">XScuGic_Connect(GicInstancePtr, GpioIntrId, (Xil_ExceptionHandler)IntrHandler, (<span class="type">void</span> *)Gpio);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置中断引脚的中断触发类型为下降沿</span></span><br><span class="line">XGpioPs_SetIntrTypePin(Gpio, MIO_KEY, XGPIOPS_IRQ_TYPE_EDGE_FALLING);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除上一次中断状态,解决上电时产生的第一次中断信号</span></span><br><span class="line">XGpioPs_IntrClearPin(Gpio, MIO_KEY);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使能具体的中断引脚信号（GPIO）</span></span><br><span class="line">XGpioPs_IntrEnablePin(Gpio, MIO_KEY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 中断服务函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IntrHandler</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;IRQ Test!\n\r&quot;</span>);</span><br><span class="line">key_press = <span class="number">1</span>;</span><br><span class="line">XGpioPs_IntrDisablePin(&amp;gpiops_inst, MIO_KEY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AXI-GPIO"><a href="#AXI-GPIO" class="headerlink" title="AXI_GPIO"></a>AXI_GPIO</h3><p>（1）AXI_GPIO是一种由FPGA资源搭建的软核，不像PS部分的GPIO有自己的电路，AXI_GPIO没有实际的硬件电路,由用户通过PL端自行配置使用</p><img src="/images/ZYNQ/image-20240425220923941.png" alt="image-20240425220923941" style="zoom:67%;" /><p>​    &lt;AXI GPIO 框架&gt;</p><img src="/images/ZYNQ/image-20240426100810297.png" alt="image-20240426100810297" style="zoom:67%;" /><p>​&lt;编程指导&gt;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 实验目的：通过AXI GPIO使用PL端的按键点亮PS端的LED */</span></span><br><span class="line"></span><br><span class="line">main函数：</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 配置及初始化PS端GPIO</span></span><br><span class="line">gpiops_cfg_ptr = XGpioPs_LookupConfig(GPIOPS_ID);</span><br><span class="line">XGpioPs_CfgInitialize(&amp;gpiops_inst, gpiops_cfg_ptr, gpiops_cfg_ptr-&gt;BaseAddr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// AXI GPIO初始化</span></span><br><span class="line">XGpio_Initialize(&amp;AXI_Gpio, AXI_GPIO_DEVICE_ID);</span><br><span class="line"></span><br><span class="line"><span class="comment">// PS端GPIO设置为输出并使能，驱动LED（0：输入/1：输出）</span></span><br><span class="line">XGpioPs_SetDirectionPin(&amp;gpiops_inst, MIO_LED0, <span class="number">1</span>);</span><br><span class="line">XGpioPs_SetOutputEnablePin(&amp;gpiops_inst, MIO_LED0, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// AXI GPIO设置为输入并使能中断</span></span><br><span class="line">XGpio_SetDataDirection(&amp;AXI_Gpio, GPIO_CHANNEL1, <span class="number">0x00000001</span>); <span class="comment">// 硬件中仅使用1bit，这里使用最低位为1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置中断</span></span><br><span class="line">SetupInterruptSystem(&amp;Intc, &amp;AXI_Gpio, AXI_GPIO_INTERRUPT_ID);</span><br><span class="line">    </span><br><span class="line"><span class="type">void</span> <span class="title function_">SetupInterruptSystem</span><span class="params">(XScuGic *GicInstancePtr, XGpio *AXI_Gpio, u16 AXI_GpioIntrId)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 配置中断控制器GIC</span></span><br><span class="line">IntcConfig = XScuGic_LookupConfig(INTC_DEVICE_ID); <span class="comment">// 查找中断控制器的配置信息</span></span><br><span class="line">XScuGic_CfgInitialize(GicInstancePtr, IntcConfig, IntcConfig-&gt;CpuBaseAddress); <span class="comment">// 初始化中断控制器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0xA0：中断源优先级，0x1：高电平敏感类型</span></span><br><span class="line">    <span class="comment">// 注意：axi_gpio的中断会在任一GPIO接口数值变化时产生一段时间的高电平，无论数值由0变1还是由1变0，因此按钮按下并弹起实际会产生2次中断的高电平</span></span><br><span class="line">XScuGic_SetPriorityTriggerType(GicInstancePtr, AXI_GpioIntrId, <span class="number">0xA0</span>, <span class="number">0x1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不管使用什么外设，只要用到中断，这几个函数就要有</span></span><br><span class="line"><span class="comment">// 初始化ARM处理器异常句柄</span></span><br><span class="line">Xil_ExceptionInit();</span><br><span class="line"><span class="comment">// IRQ异常注册处理程序</span></span><br><span class="line">Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT, (Xil_ExceptionHandler)XScuGic_InterruptHandler, GicInstancePtr);</span><br><span class="line"><span class="comment">// 使能处理器的中断</span></span><br><span class="line">Xil_ExceptionEnableMask(XIL_EXCEPTION_IRQ);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关联中断处理函数</span></span><br><span class="line">XScuGic_Connect(GicInstancePtr, AXI_GpioIntrId, (Xil_ExceptionHandler)IntrHandler, (<span class="type">void</span> *)AXI_Gpio);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为AXI GPIO器件使能中断，打开中断控制器的使能（GIC）</span></span><br><span class="line">XScuGic_Enable(GicInstancePtr, AXI_GpioIntrId);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开AXI GPIO IP的中断使能</span></span><br><span class="line">XGpio_InterruptGlobalEnable(AXI_Gpio); <span class="comment">// 打开全局中断使能</span></span><br><span class="line">XGpio_InterruptEnable(AXI_Gpio, <span class="number">0x00000001</span>); <span class="comment">// 打开通道中的中断使能</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 中断服务函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IntrHandler</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;IRQ Test!\n\r&quot;</span>);</span><br><span class="line">key_press = <span class="number">1</span>;</span><br><span class="line">XGpio_InterruptDisable(&amp;AXI_Gpio, <span class="number">0x00000001</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义IP核"><a href="#自定义IP核" class="headerlink" title="自定义IP核"></a>自定义IP核</h2><p>（1）基础知识参考ug1118，实操流程参考ZYNQ小系统板之嵌入式SDK开发指南</p><p>（2）自定义IP核，可以实现将模块集成到IP库中。在 Vivado 软件中，通过创建和封装 IP 向导的方式来自定义 IP 核，支持将当前工程、工程中的模块或者指定文件目录封装成 IP 核，当然也可以创建一个带有 AXI4 接口的 IP 核，用于 PS 和 PL 的数据通信。</p><img src="/images/ZYNQ/image-20240428164252896.png" alt="image-20240428164252896" style="zoom: 67%;" /><h2 id="程序固化实验"><a href="#程序固化实验" class="headerlink" title="程序固化实验"></a>程序固化实验</h2><img src="/images/ZYNQ/image-20240428180244453.png" alt="image-20240428180244453" style="zoom:80%;" /><p>（1）ZYNQ包括PL和PS，程序固化时，不能单独固化PL的部分，PL的启动依赖于PS，因此需要固化PS再固化PL程序</p><img src="/images/ZYNQ/image-20240428212243966.png" alt="image-20240428212243966" style="zoom:50%;" /><p>（2）程序固化就是将FSBL文件、bit流文件和用户程序合成BOOT.bin文件</p><p>（3）BOOT.bin文件拷贝到SD卡，可以直接从SD卡中启动；通过JTAG将BOOT烧录到QSPI FLASH中，可以从QSPI FLASH中启动（该两种方式均不易丢失，掉电后重新上电，仍可以读取程序并运行）</p><h2 id="UART串口中断"><a href="#UART串口中断" class="headerlink" title="UART串口中断"></a>UART串口中断</h2><img src="/images/ZYNQ/image-20240429112107583.png" alt="image-20240429112107583" style="zoom: 80%;" /><img src="/images/ZYNQ/image-20240429112216131.png" alt="image-20240429112216131" style="zoom:80%;" /><img src="/images/ZYNQ/image-20240429112232833.png" alt="image-20240429112232833" style="zoom:80%;" /><p><strong>（1）xintc和xscugic有什么区别？</strong></p><ul><li><p>XScuGic 用于 ARM 硬核的内置中断控制器，而 XIntc 用于 AXI 中断控制器，这是 AMD-XILINX 拥有的软 IP。</p><p>  XScuGic 只能在 ARM 应用程序中使用。另一方面，XIntc 可用于 ARM&#x2F;Microblaze&#x2F;PCIE 等</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * main.c</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Created on: 2024年4月29日</span></span><br><span class="line"><span class="comment"> *      Author: yxf_f</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xparameters.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xuartps.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xscugic.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xil_exception.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART_DEVICE_IDXPAR_XUARTPS_0_DEVICE_ID  <span class="comment">// 串口器件ID</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTC_DEVICE_IDXPAR_SCUGIC_SINGLE_DEVICE_ID <span class="comment">// 中断控制器器件ID</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART_INT_IRQ_IDXPS_UART0_INT_ID<span class="comment">// 串口中断号</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRIGGER_LEVEL 1<span class="comment">// 接收FIFO的触发阈值</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BAUDRATE 115200<span class="comment">// 波特率</span></span></span><br><span class="line"></span><br><span class="line">XUartPs UartPs;<span class="comment">// 实例化UART器件</span></span><br><span class="line">XScuGic InterruptController;<span class="comment">// 实例化中断控制器器件</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">UART_init</span><span class="params">(XUartPs *UartInstPtr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">INTR_init</span><span class="params">(XUartPs *UartInstPtr, XScuGic *IntcInstPtr)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IntrHandler</span><span class="params">(<span class="type">void</span> *CallbackRef)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// UART初始化</span></span><br><span class="line"><span class="type">int</span> uart_init_state = UART_init(&amp;UartPs);</span><br><span class="line"><span class="keyword">if</span> (XST_FAILURE == uart_init_state) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;UART Failed!\n\r&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> XST_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中断控制器初始化</span></span><br><span class="line"><span class="type">int</span> intr_init_state = INTR_init(&amp;UartPs, &amp;InterruptController);</span><br><span class="line"><span class="keyword">if</span> (XST_FAILURE == intr_init_state) &#123;</span><br><span class="line"><span class="keyword">return</span> XST_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> XST_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口初始化 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">UART_init</span><span class="params">(XUartPs *UartInstPtr)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> Status;</span><br><span class="line">XUartPs_Config *Config;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找串口器件</span></span><br><span class="line">Config = XUartPs_LookupConfig(UART_DEVICE_ID);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == Config) &#123;</span><br><span class="line"><span class="keyword">return</span> XST_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 配置串口</span></span><br><span class="line">XUartPs_CfgInitialize(UartInstPtr, Config, Config-&gt;BaseAddress);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 硬件自检</span></span><br><span class="line">Status = XUartPs_SelfTest(UartInstPtr);</span><br><span class="line"><span class="keyword">if</span> (Status != XST_SUCCESS) &#123;</span><br><span class="line"><span class="keyword">return</span> XST_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 串口模式设置</span></span><br><span class="line">XUartPs_SetOperMode(UartInstPtr, XUARTPS_OPER_MODE_NORMAL);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置波特率</span></span><br><span class="line">XUartPs_SetBaudRate(UartInstPtr, BAUDRATE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置接收FIFO的触发阈值</span></span><br><span class="line">XUartPs_SetFifoThreshold(UartInstPtr, TRIGGER_LEVEL);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 中断初始化 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">INTR_init</span><span class="params">(XUartPs *UartInstPtr, XScuGic *IntcInstPtr)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> Status;</span><br><span class="line">XScuGic_Config *IntcConfig;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* GIC */</span></span><br><span class="line"><span class="comment">// GIC中断控制器配置</span></span><br><span class="line">IntcConfig = XScuGic_LookupConfig(INTC_DEVICE_ID); <span class="comment">// 查找中断控制器的配置信息</span></span><br><span class="line">Status = XScuGic_CfgInitialize(IntcInstPtr, IntcConfig, IntcConfig-&gt;CpuBaseAddress); <span class="comment">// 初始化中断控制器</span></span><br><span class="line"><span class="keyword">if</span> (Status != XST_SUCCESS) &#123;</span><br><span class="line"><span class="keyword">return</span> XST_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不管使用什么外设，只要用到中断，这几个函数就要有</span></span><br><span class="line">Xil_ExceptionInit();</span><br><span class="line">Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT, (Xil_ExceptionHandler)XScuGic_InterruptHandler, IntcInstPtr);</span><br><span class="line">Xil_ExceptionEnable();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关联中断处理函数</span></span><br><span class="line">XScuGic_Connect(IntcInstPtr, UART_INT_IRQ_ID, (Xil_ExceptionHandler)IntrHandler, UartInstPtr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为UART器件使能中断，打开中断控制器的使能（GIC）</span></span><br><span class="line">XScuGic_Enable(IntcInstPtr, UART_INT_IRQ_ID);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* UART */</span></span><br><span class="line"><span class="comment">// UART外设中断触发方式（接收阈值触发中断）</span></span><br><span class="line">XUartPs_SetInterruptMask(UartInstPtr, XUARTPS_IXR_RXOVR);</span><br><span class="line"><span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IntrHandler</span><span class="params">(<span class="type">void</span> *CallbackRef)</span></span><br><span class="line">&#123;</span><br><span class="line">u8 rev_data;</span><br><span class="line">u32 IsrStatus;</span><br><span class="line">XUartPs *uart_instance_ptr = (XUartPs *)CallbackRef;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取中断状态寄存器的值（读出的值和前面配置的应该一致）</span></span><br><span class="line">IsrStatus = XUartPs_ReadReg(uart_instance_ptr-&gt;Config.BaseAddress,</span><br><span class="line">   XUARTPS_IMR_OFFSET);</span><br><span class="line">IsrStatus &amp;= XUartPs_ReadReg(uart_instance_ptr-&gt;Config.BaseAddress,</span><br><span class="line">   XUARTPS_ISR_OFFSET);</span><br><span class="line"><span class="comment">// 根据状态寄存器的值判断接收数据是否达到阈值</span></span><br><span class="line"><span class="keyword">if</span>((IsrStatus &amp; (u32)XUARTPS_IXR_RXOVR) != (u32)<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">rev_data = XUartPs_RecvByte(uart_instance_ptr-&gt;Config.BaseAddress);</span><br><span class="line"><span class="comment">// 清除中断标志（往状态寄存器对应的位写1，即可清除）</span></span><br><span class="line">XUartPs_WriteReg(uart_instance_ptr-&gt;Config.BaseAddress, XUARTPS_ISR_OFFSET, IsrStatus);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">XUartPs_SendByte(uart_instance_ptr-&gt;Config.BaseAddress, rev_data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定时器中断"><a href="#定时器中断" class="headerlink" title="定时器中断"></a>定时器中断</h2><h3 id="定时器简介"><a href="#定时器简介" class="headerlink" title="定时器简介"></a>定时器简介</h3><img src="../images/ZYNQ/image-20240506110427711.png" alt="image-20240506110427711" style="zoom:80%;" /><p>（1）所有的私有定时器和看门狗定时器的时钟是1&#x2F;2系统时钟，也就是333.333MHz</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * main.c</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Created on: 2024年4月30日</span></span><br><span class="line"><span class="comment"> *      Author: yxf_f</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xparameters.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xgpiops.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xstatus.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xplatform_info.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xil_printf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xscutimer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xscugic.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_DEVICE_ID  XPAR_XGPIOPS_0_DEVICE_ID<span class="comment">// GPIO器件ID</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER_DEVICE_IDXPAR_XSCUTIMER_0_DEVICE_ID<span class="comment">// TIMER器件ID</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTC_DEVICE_IDXPAR_SCUGIC_SINGLE_DEVICE_ID<span class="comment">// 中断器件ID</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER_INTR_IDXPAR_SCUTIMER_INTR<span class="comment">// 私有定时器中断号ID</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIOLED0 7<span class="comment">// LED引脚号</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER_LOAD_VALUE0x3F94067 <span class="comment">// 装载值，200ms / 1 /333.333MHz</span></span></span><br><span class="line"></span><br><span class="line">XGpioPs Gpio;<span class="comment">// GPIO驱动实例</span></span><br><span class="line">XScuTimer TimerInstance;<span class="comment">// TIMER驱动实例</span></span><br><span class="line">XScuGic IntcInstance;<span class="comment">// GIC驱动实例</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MIO_init</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TIMER_init</span><span class="params">(XScuGic *IntcInstancePtr, XScuTimer * TimerInstancePtr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">INTR_init</span><span class="params">(XScuGic *IntcInstancePtr, XScuTimer * TimerInstancePtr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">timer_intr_handler</span><span class="params">(<span class="type">void</span> *CallBackRef)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Timer Test\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// MIO初始化配置</span></span><br><span class="line"><span class="built_in">MIO_init</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// TIMER初始化配置</span></span><br><span class="line"><span class="built_in">TIMER_init</span>(&amp;IntcInstance, &amp;TimerInstance);</span><br><span class="line"></span><br><span class="line"><span class="comment">// INTR初始化配置</span></span><br><span class="line"><span class="built_in">INTR_init</span>(&amp;IntcInstance, &amp;TimerInstance);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全部配置完成后，启动定时器</span></span><br><span class="line"><span class="built_in">XScuTimer_Start</span>(&amp;TimerInstance);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> XST_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* MIO */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MIO_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> Status;</span><br><span class="line">XGpioPs_Config *ConfigPtr;</span><br><span class="line">ConfigPtr = <span class="built_in">XGpioPs_LookupConfig</span>(GPIO_DEVICE_ID);</span><br><span class="line">Status = <span class="built_in">XGpioPs_CfgInitialize</span>(&amp;Gpio, ConfigPtr, ConfigPtr-&gt;BaseAddr);</span><br><span class="line"><span class="keyword">if</span> (Status != XST_SUCCESS)</span><br><span class="line"><span class="keyword">return</span> XST_FAILURE;</span><br><span class="line"></span><br><span class="line"><span class="built_in">XGpioPs_SetDirectionPin</span>(&amp;Gpio, MIOLED0, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">XGpioPs_SetOutputEnablePin</span>(&amp;Gpio, MIOLED0, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> XST_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TIMER */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TIMER_init</span><span class="params">(XScuGic *IntcInstancePtr, XScuTimer * TimerInstancePtr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> Status;</span><br><span class="line">XScuTimer_Config *ConfigPtr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TIMER初始化配置</span></span><br><span class="line">ConfigPtr = <span class="built_in">XScuTimer_LookupConfig</span>(TIMER_DEVICE_ID);</span><br><span class="line">Status = <span class="built_in">XScuTimer_CfgInitialize</span>(TimerInstancePtr, ConfigPtr,</span><br><span class="line">ConfigPtr-&gt;BaseAddr);</span><br><span class="line"><span class="keyword">if</span> (Status != XST_SUCCESS) &#123;</span><br><span class="line"><span class="keyword">return</span> XST_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自检</span></span><br><span class="line">Status = <span class="built_in">XScuTimer_SelfTest</span>(TimerInstancePtr);</span><br><span class="line"><span class="keyword">if</span> (Status != XST_SUCCESS) &#123;</span><br><span class="line"><span class="keyword">return</span> XST_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置重装载值</span></span><br><span class="line"><span class="built_in">XScuTimer_LoadTimer</span>(TimerInstancePtr, TIMER_LOAD_VALUE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使能自动重装载</span></span><br><span class="line"><span class="built_in">XScuTimer_EnableAutoReload</span>(TimerInstancePtr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> XST_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">INTR_init</span><span class="params">(XScuGic *IntcInstancePtr, XScuTimer * TimerInstancePtr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> Status;</span><br><span class="line">XScuGic_Config *IntcConfig;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中断控制器GIC初始化配置</span></span><br><span class="line">IntcConfig = <span class="built_in">XScuGic_LookupConfig</span>(INTC_DEVICE_ID);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == IntcConfig) &#123;</span><br><span class="line"><span class="keyword">return</span> XST_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line">Status = <span class="built_in">XScuGic_CfgInitialize</span>(IntcInstancePtr, IntcConfig, IntcConfig-&gt;CpuBaseAddress);</span><br><span class="line"><span class="keyword">if</span> (Status != XST_SUCCESS) &#123;</span><br><span class="line"><span class="keyword">return</span> XST_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中断异常处理，中断必加</span></span><br><span class="line"><span class="built_in">Xil_ExceptionInit</span>();</span><br><span class="line"><span class="built_in">Xil_ExceptionRegisterHandler</span>(XIL_EXCEPTION_ID_IRQ_INT,</span><br><span class="line">(Xil_ExceptionHandler)XScuGic_InterruptHandler,</span><br><span class="line">IntcInstancePtr);</span><br><span class="line"><span class="built_in">Xil_ExceptionEnable</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中断服务程序链接</span></span><br><span class="line">Status = <span class="built_in">XScuGic_Connect</span>(IntcInstancePtr, TIMER_INTR_ID,</span><br><span class="line">(Xil_ExceptionHandler)timer_intr_handler,</span><br><span class="line">(<span class="type">void</span> *)TimerInstancePtr);</span><br><span class="line"><span class="keyword">if</span> (Status != XST_SUCCESS) &#123;</span><br><span class="line"><span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使能GIC中断控制器</span></span><br><span class="line"><span class="built_in">XScuGic_Enable</span>(IntcInstancePtr, TIMER_INTR_ID);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使能TIMER定时器中断</span></span><br><span class="line"><span class="built_in">XScuTimer_EnableInterrupt</span>(TimerInstancePtr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> XST_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">timer_intr_handler</span><span class="params">(<span class="type">void</span> *CallBackRef)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> led_state = <span class="number">0</span>;</span><br><span class="line">XScuTimer *TimerInstancePtr = (XScuTimer *) CallBackRef;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">XScuTimer_IsExpired</span>(TimerInstancePtr)) &#123;</span><br><span class="line"><span class="built_in">XScuTimer_ClearInterruptStatus</span>(TimerInstancePtr);</span><br><span class="line"><span class="built_in">XGpioPs_WritePin</span>(&amp;Gpio, MIOLED0, led_state);</span><br><span class="line">led_state = ~led_state;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PS-XADC接口"><a href="#PS-XADC接口" class="headerlink" title="PS XADC接口"></a>PS XADC接口</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * main.c</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Created on: 2024年5月6日</span></span><br><span class="line"><span class="comment"> *      Author: yxf_f</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xparameters.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xadcps.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sleep.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XADC_DEVICE_ID XPAR_XADCPS_0_DEVICE_ID<span class="comment">// XADC器件ID</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> XAdcPs XAdcInst;<span class="comment">// XADC实例</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ps_xadc_init</span><span class="params">(u16 XAdcDeviceId)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ps_xadc_print</span><span class="params">(XAdcPs *XAdcInstPtr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">XAdcFractionToInt</span><span class="params">(<span class="type">float</span> FloatNum)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="type">int</span> Status;</span><br><span class="line"></span><br><span class="line">Status = ps_xadc_init(XADC_DEVICE_ID);</span><br><span class="line"><span class="keyword">if</span> (Status != XST_SUCCESS) &#123;</span><br><span class="line">xil_printf(<span class="string">&quot;adcps polled printf Example Failed\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> XST_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line">xil_printf(<span class="string">&quot;Successfully ran adcps polled printf Example\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">u32 TempRawData = XAdcPs_GetAdcData(&amp;XAdcInst, XADCPS_CH_TEMP);</span><br><span class="line"><span class="type">float</span> TempData = XAdcPs_RawToTemperature(TempRawData);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The Current Temperature is %0d.%03d Centigrades.\r\n&quot;</span>,</span><br><span class="line">(<span class="type">int</span>) (TempData), XAdcFractionToInt(TempData));</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> XST_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ps_xadc_init</span><span class="params">(u16 XAdcDeviceId)</span> &#123;</span><br><span class="line"><span class="type">int</span> Status;</span><br><span class="line">XAdcPs_Config *ConfigPtr;</span><br><span class="line">XAdcPs *XAdcInstPtr = &amp;XAdcInst;</span><br><span class="line"></span><br><span class="line"><span class="comment">// XADC初始化配置</span></span><br><span class="line">ConfigPtr = XAdcPs_LookupConfig(XAdcDeviceId);</span><br><span class="line"><span class="keyword">if</span> (ConfigPtr == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> XST_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line">XAdcPs_CfgInitialize(XAdcInstPtr, ConfigPtr, ConfigPtr-&gt;BaseAddress);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自检</span></span><br><span class="line">Status = XAdcPs_SelfTest(XAdcInstPtr);</span><br><span class="line"><span class="keyword">if</span> (Status != XST_SUCCESS) &#123;</span><br><span class="line"><span class="keyword">return</span> XST_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置成正常模式/安全模式</span></span><br><span class="line">XAdcPs_SetSequencerMode(XAdcInstPtr, XADCPS_SEQ_MODE_SAFE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ps_xadc_print</span><span class="params">(XAdcPs *XAdcInstPtr)</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;start the XAdc Polled Example. \r\n&quot;</span>);</span><br><span class="line"><span class="comment">// 温度</span></span><br><span class="line">u32 TempRawData = XAdcPs_GetAdcData(XAdcInstPtr, XADCPS_CH_TEMP);</span><br><span class="line"><span class="type">float</span> TempData = XAdcPs_RawToTemperature(TempRawData);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The Current Temperature is %0d.%03d Centigrades.\r\n&quot;</span>,</span><br><span class="line">(<span class="type">int</span>) (TempData), XAdcFractionToInt(TempData));</span><br><span class="line"></span><br><span class="line">TempRawData = XAdcPs_GetMinMaxMeasurement(XAdcInstPtr, XADCPS_MAX_TEMP);</span><br><span class="line"><span class="type">float</span> MaxData = XAdcPs_RawToTemperature(TempRawData);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The Maximum Temperature is %0d.%03d Centigrades. \r\n&quot;</span>,</span><br><span class="line">(<span class="type">int</span>) (MaxData), XAdcFractionToInt(MaxData));</span><br><span class="line"></span><br><span class="line">TempRawData = XAdcPs_GetMinMaxMeasurement(XAdcInstPtr, XADCPS_MIN_TEMP);</span><br><span class="line"><span class="type">float</span> MinData = XAdcPs_RawToTemperature(TempRawData &amp; <span class="number">0xFFF0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The Minimum Temperature is %0d.%03d Centigrades. \r\n&quot;</span>,</span><br><span class="line">(<span class="type">int</span>) (MinData), XAdcFractionToInt(MinData));</span><br><span class="line"></span><br><span class="line"><span class="comment">// VccPint 电压</span></span><br><span class="line">u32 VccPintRawData = XAdcPs_GetAdcData(XAdcInstPtr, XADCPS_CH_VCCPINT);</span><br><span class="line"><span class="type">float</span> VccPintData = XAdcPs_RawToVoltage(VccPintRawData);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The Current VCCPINT is %0d.%03d Volts. \r\n&quot;</span>,</span><br><span class="line">(<span class="type">int</span>) (VccPintData), XAdcFractionToInt(VccPintData));</span><br><span class="line"></span><br><span class="line">VccPintRawData = XAdcPs_GetMinMaxMeasurement(XAdcInstPtr,</span><br><span class="line">XADCPS_MAX_VCCPINT);</span><br><span class="line">MaxData = XAdcPs_RawToVoltage(VccPintRawData);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The Maximum VCCPINT is %0d.%03d Volts. \r\n&quot;</span>, (<span class="type">int</span>) (MaxData),</span><br><span class="line">XAdcFractionToInt(MaxData));</span><br><span class="line"></span><br><span class="line">VccPintRawData = XAdcPs_GetMinMaxMeasurement(XAdcInstPtr,</span><br><span class="line">XADCPS_MIN_VCCPINT);</span><br><span class="line">MinData = XAdcPs_RawToVoltage(VccPintRawData);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The Minimum VCCPINT is %0d.%03d Volts. \r\n&quot;</span>, (<span class="type">int</span>) (MinData),</span><br><span class="line">XAdcFractionToInt(MinData));</span><br><span class="line"></span><br><span class="line"><span class="comment">// VccPaux 电压</span></span><br><span class="line">u32 VccPauxRawData = XAdcPs_GetAdcData(XAdcInstPtr, XADCPS_CH_VCCPAUX);</span><br><span class="line"><span class="type">float</span> VccPauxData = XAdcPs_RawToVoltage(VccPauxRawData);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The Current VCCPAUX is %0d.%03d Volts. \r\n&quot;</span>,</span><br><span class="line">(<span class="type">int</span>) (VccPauxData), XAdcFractionToInt(VccPauxData));</span><br><span class="line"></span><br><span class="line">VccPauxRawData = XAdcPs_GetMinMaxMeasurement(XAdcInstPtr,</span><br><span class="line">XADCPS_MAX_VCCPAUX);</span><br><span class="line">MaxData = XAdcPs_RawToVoltage(VccPauxRawData);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The Maximum VCCPAUX is %0d.%03d Volts. \r\n&quot;</span>, (<span class="type">int</span>) (MaxData),</span><br><span class="line">XAdcFractionToInt(MaxData));</span><br><span class="line"></span><br><span class="line">VccPauxRawData = XAdcPs_GetMinMaxMeasurement(XAdcInstPtr,</span><br><span class="line">XADCPS_MIN_VCCPAUX);</span><br><span class="line">MinData = XAdcPs_RawToVoltage(VccPauxRawData);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The Minimum VCCPAUX is %0d.%03d Volts. \r\n&quot;</span>, (<span class="type">int</span>) (MinData),</span><br><span class="line">XAdcFractionToInt(MinData));</span><br><span class="line"></span><br><span class="line"><span class="comment">// VccPdro Votage</span></span><br><span class="line">u32 VccPdroRawData = XAdcPs_GetAdcData(XAdcInstPtr, XADCPS_CH_VCCPDRO);</span><br><span class="line">VccPintData = XAdcPs_RawToVoltage(VccPdroRawData);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The Current VCCPDDRO is %0d.%03d Volts. \r\n&quot;</span>,</span><br><span class="line">(<span class="type">int</span>) (VccPintData), XAdcFractionToInt(VccPintData));</span><br><span class="line"></span><br><span class="line">VccPdroRawData = XAdcPs_GetMinMaxMeasurement(XAdcInstPtr,</span><br><span class="line">XADCPS_MAX_VCCPDRO);</span><br><span class="line">MaxData = XAdcPs_RawToVoltage(VccPdroRawData);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The Maximum VCCPDDRO is %0d.%03d Volts. \r\n&quot;</span>, (<span class="type">int</span>) (MaxData),</span><br><span class="line">XAdcFractionToInt(MaxData));</span><br><span class="line"></span><br><span class="line">VccPdroRawData = XAdcPs_GetMinMaxMeasurement(XAdcInstPtr,</span><br><span class="line">XADCPS_MIN_VCCPDRO);</span><br><span class="line">MinData = XAdcPs_RawToVoltage(VccPdroRawData);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The Minimum VCCPDDRO is %0d.%03d Volts. \r\n&quot;</span>, (<span class="type">int</span>) (MinData),</span><br><span class="line">XAdcFractionToInt(MinData));</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Exiting the XAdc Polled Example. \r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">XAdcFractionToInt</span><span class="params">(<span class="type">float</span> FloatNum)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> Temp;</span><br><span class="line"></span><br><span class="line">Temp = FloatNum;</span><br><span class="line"><span class="keyword">if</span> (FloatNum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">Temp = -(FloatNum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>( ((<span class="type">int</span>)((Temp -(<span class="type">float</span>)((<span class="type">int</span>)Temp)) * (<span class="number">1000.0f</span>))));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="FLASH"><a href="#FLASH" class="headerlink" title="FLASH"></a>FLASH</h2><h3 id="flash简介"><a href="#flash简介" class="headerlink" title="flash简介"></a>flash简介</h3><img src="../images/ZYNQ/image-20240506164928801.png" alt="image-20240506164928801" style="zoom: 50%;" /><h3 id="flash分类"><a href="#flash分类" class="headerlink" title="flash分类"></a>flash分类</h3><img src="../images/ZYNQ/image-20240506165231098.png" alt="image-20240506165231098" style="zoom: 50%;" /><img src="../images/ZYNQ/image-20240506165456603.png" alt="image-20240506165456603" style="zoom:50%;" /><h3 id="QSPI-FLASH接口"><a href="#QSPI-FLASH接口" class="headerlink" title="QSPI  FLASH接口"></a>QSPI  FLASH接口</h3><p>（1）四根数据线，读写更快</p><img src="../images/ZYNQ/image-20240506165723615.png" alt="image-20240506165723615" style="zoom:50%;" /><h2 id="SD卡"><a href="#SD卡" class="headerlink" title="SD卡"></a>SD卡</h2><h3 id="SD卡简介"><a href="#SD卡简介" class="headerlink" title="SD卡简介"></a>SD卡简介</h3><p>（1）SD 卡共有 9 个引脚线，可工作在 SDIO 模式或者 SPI 模式。在 SDIO 模式下，共用到 CLK、CMD、DAT[3:0]<br>六根信号线；在 SPI 模式下，共用到 CS（SDIO_DAT[3]）、CLK（SDIO_CLK）、MISO（SDIO_DAT[0]）、MOSI（SDIO_CMD）四根信号线。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * main.c</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Created on: 2024年5月7日</span></span><br><span class="line"><span class="comment"> *      Author: yxf_f</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xparameters.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xil_printf.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ff.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xdevcfg.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILE_NAME <span class="string">&quot;ZDYZ.txt&quot;</span>                <span class="comment">//定义文件名</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> src_str[<span class="number">30</span>] = <span class="string">&quot;zynq xilink&quot;</span>; <span class="comment">//定义文本内容</span></span><br><span class="line"><span class="type">static</span> FATFS fatfs;                         <span class="comment">//文件系统</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化文件系统</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">platform_init_fs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FRESULT status;</span><br><span class="line">TCHAR *Path = <span class="string">&quot;0:/&quot;</span>;</span><br><span class="line">BYTE work[FF_MAX_SS];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册一个工作区(挂载分区文件系统)</span></span><br><span class="line">    <span class="comment">//在使用任何其它文件函数之前，必须使用f_mount函数为每个使用卷注册一个工作区</span></span><br><span class="line">status = <span class="built_in">f_mount</span>(&amp;fatfs, Path, <span class="number">1</span>);  <span class="comment">//挂载SD卡</span></span><br><span class="line"><span class="keyword">if</span> (status != FR_OK) &#123;</span><br><span class="line"><span class="built_in">xil_printf</span>(<span class="string">&quot;Volume is not FAT formated; formating FAT\r\n&quot;</span>);</span><br><span class="line"><span class="comment">//格式化SD卡</span></span><br><span class="line">status = <span class="built_in">f_mkfs</span>(Path, FM_FAT32, <span class="number">0</span>, work, <span class="built_in">sizeof</span>(work));</span><br><span class="line"><span class="keyword">if</span> (status != FR_OK) &#123;</span><br><span class="line"><span class="built_in">xil_printf</span>(<span class="string">&quot;Unable to format FATfs\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//格式化之后，重新挂载SD卡</span></span><br><span class="line">status = <span class="built_in">f_mount</span>(&amp;fatfs, Path, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (status != FR_OK) &#123;</span><br><span class="line"><span class="built_in">xil_printf</span>(<span class="string">&quot;Unable to mount FATfs\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//挂载SD(TF)卡</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sd_mount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FRESULT status;</span><br><span class="line">    <span class="comment">//初始化文件系统（挂载SD卡，如果挂载不成功，则格式化SD卡）</span></span><br><span class="line">    status = <span class="built_in">platform_init_fs</span>();</span><br><span class="line">    <span class="keyword">if</span>(status)&#123;</span><br><span class="line">        <span class="built_in">xil_printf</span>(<span class="string">&quot;ERROR: f_mount returned %d!\n&quot;</span>,status);</span><br><span class="line">        <span class="keyword">return</span> XST_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> XST_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SD卡写数据</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sd_write_data</span><span class="params">(<span class="type">char</span> *file_name,u32 src_addr,u32 byte_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FIL fil;         <span class="comment">//文件对象</span></span><br><span class="line">    UINT bw;         <span class="comment">//f_write函数返回已写入的字节数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开一个文件,如果不存在，则创建一个文件</span></span><br><span class="line">    <span class="built_in">f_open</span>(&amp;fil,file_name,FA_CREATE_ALWAYS | FA_WRITE);</span><br><span class="line">    <span class="comment">//移动打开的文件对象的文件读/写指针     0:指向文件开头</span></span><br><span class="line">    <span class="built_in">f_lseek</span>(&amp;fil, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//向文件中写入数据</span></span><br><span class="line">    <span class="built_in">f_write</span>(&amp;fil,(<span class="type">void</span>*) src_addr,byte_len,&amp;bw);</span><br><span class="line">    <span class="comment">//关闭文件</span></span><br><span class="line">    <span class="built_in">f_close</span>(&amp;fil);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SD卡读数据</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sd_read_data</span><span class="params">(<span class="type">char</span> *file_name,u32 src_addr,u32 byte_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FIL fil;         <span class="comment">//文件对象</span></span><br><span class="line">    UINT br;         <span class="comment">//f_read函数返回已读出的字节数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开一个只读的文件</span></span><br><span class="line">    <span class="built_in">f_open</span>(&amp;fil,file_name,FA_READ);</span><br><span class="line">    <span class="comment">//移动打开的文件对象的文件读/写指针     0:指向文件开头</span></span><br><span class="line">    <span class="built_in">f_lseek</span>(&amp;fil,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//从SD卡中读出数据</span></span><br><span class="line">    <span class="built_in">f_read</span>(&amp;fil,(<span class="type">void</span>*)src_addr,byte_len,&amp;br);</span><br><span class="line">    <span class="comment">//关闭文件</span></span><br><span class="line">    <span class="built_in">f_close</span>(&amp;fil);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> status,len;</span><br><span class="line">    <span class="type">char</span> dest_str[<span class="number">30</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    status = <span class="built_in">sd_mount</span>();           <span class="comment">//挂载SD卡</span></span><br><span class="line">    <span class="keyword">if</span>(status != XST_SUCCESS)&#123;</span><br><span class="line"><span class="built_in">xil_printf</span>(<span class="string">&quot;Failed to open SD card!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">xil_printf</span>(<span class="string">&quot;Success to open SD card!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    len = <span class="built_in">strlen</span>(src_str);         <span class="comment">//计算字符串长度</span></span><br><span class="line">    <span class="comment">//SD卡写数据</span></span><br><span class="line">    <span class="built_in">sd_write_data</span>(FILE_NAME,(u32)src_str,len);</span><br><span class="line">    <span class="comment">//SD卡读数据</span></span><br><span class="line">    <span class="built_in">sd_read_data</span>(FILE_NAME,(u32)dest_str,len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//比较写入的字符串和读出的字符串是否相等</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(src_str, dest_str) == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">xil_printf</span>(<span class="string">&quot;src_str is equal to dest_str,SD card test success!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">xil_printf</span>(<span class="string">&quot;src_str is not equal to dest_str,SD card test failed!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="AXI协议"><a href="#AXI协议" class="headerlink" title="AXI协议"></a>AXI协议</h2><p><em><strong>（参考：<a href="https://blog.csdn.net/lum250/article/details/120912567">AXI4协议学习：架构、信号定义、工作时序和握手机制-CSDN博客</a>）</strong></em></p><h3 id="AXI定义"><a href="#AXI定义" class="headerlink" title="AXI定义"></a>AXI定义</h3><ul><li>AXI，（advanced extensible interface) 高级扩展接口，属于AMBA（advanced  microcontroller bus architecture）高级微控制器总线架构。</li></ul><h3 id="AXI分类"><a href="#AXI分类" class="headerlink" title="AXI分类"></a>AXI分类</h3><ul><li><p>AXI4：高性能存储器映射接口，大量数据通信，用于处理器访问存储器等需要指定地址的高速数据传输场景，<strong>支持突发传输模式，一个地址传输256个数据。</strong></p></li><li><p>AXI4-Lite：简化版的AXI4接口，少量数据的存储器映射通信，提供单个数据传输，用于低速外设的访问，<strong>不支持突发数据传输模式。</strong></p></li><li><p>AXI-Stream：高速数据流传输接口，<strong>非存储映射接口，即不需要地址</strong>，用于视频、PCIE、DMA和高速AD等场景，<strong>支持不限数据长度的突发传输模式</strong>。（通常可以使用AXI Direct Memory Access (DMA) engines将Stream移进或移出内存）</p></li></ul><h3 id="AXI工作方式"><a href="#AXI工作方式" class="headerlink" title="AXI工作方式"></a>AXI工作方式</h3><p>（1）AXI规范描述了单个AXI主（master）从（slave）之间的接口。</p><p>（2）<strong>多个Master和Slave之间的内存映射可以通过Xilinx AXI Interconnect IP 和 AXI SmartConnect IP 连接在一起</strong></p><p>（3）数据可以同时在主-&gt;从和从-&gt;主两个方向传输。数据传输的大小可以变化。<strong>AXI4</strong>中的限制是最多<strong>256</strong>个数据传输的突发事务。<strong>AXI4-Lite</strong>只允许每个事务进行<strong>1</strong>个数据传输。</p><p>（4）AXI4 和 AXI4-Lite有5个独立的数据通道（参考 PDF INI0022dD）</p><p><img src="/images/ZYNQ/image-20240511121109920.png" alt="image-20240511121109920"></p><ul><li>每一个独立的通道都包含一组信息信号（读写地址、数据等信号）、VALID信号和READY信号，用于提供双向握手机制</li><li>信息源端使用VALID信号表示当前通道地址、数据和控制信息什么时候有效；信息目的端使用READY信号表示什么时候可以接收信息；读数据通道和写数据通道都包含一个LAST信号，用于表示传输的最后一个数据。</li><li>读数据通道和写数据通道都包含各自的地址通道，地址通道携带了请求所需的地址和信息</li><li>读数据通道从机——&gt;主机，包含了读数据和读响应的信息，读响应的信号用于表示传输是否完成</li><li>写数据通道主机——&gt;从机，包含了写数据，通过WSTRB信号表示当前数据的那个字节有效</li><li>写响应通道从机——&gt;主机，包含了写响应信号，用于表示写操作是否完成</li><li>所有的五个通道都是通过相同的VALID&#x2F;READY握手处理来传输地址、数据和控制信息，双向握手的机制意味着主机和从机之间传输数据时，都可以控制传输的速率</li><li>只有当VALID和READY信号都为高，传输才会开始</li></ul><h3 id="AXI时序示例"><a href="#AXI时序示例" class="headerlink" title="AXI时序示例"></a>AXI时序示例</h3><ol><li><p>突发读示例</p>  <img src="/images/ZYNQ/%E7%AA%81%E5%8F%91%E8%AF%BB%E6%97%B6%E5%BA%8F.png" alt="突发读时序" style="zoom:80%;" />  <ul><li>ARVALID和ARREADY都拉高，地址有效，地址传输到从机<ul><li>RVALID和RREADY都拉高，数据传输到从机</li><li>RLAST与第四个数据D3同步，表示最后一个数据</li></ul></li></ul></li><li><p>重叠突发读示例</p><p> <img src="/images/ZYNQ/%E9%87%8D%E5%8F%A0%E7%AA%81%E5%8F%91%E8%AF%BB.png" alt="重叠突发读"></p><ul><li>可以连续发送多个地址，两个突发读也是连续的，但是都有自己的结束RLAST</li></ul></li><li><p>突发写时序</p><p> <img src="/images/ZYNQ/%E7%AA%81%E5%8F%91%E5%86%99.png" alt="突发写"></p><ul><li>从机接收到数据后，向主机发送一个写响应，表明写事务已经完成</li></ul></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>AXI协议</title>
      <link href="/2024/04/16/AXI/"/>
      <url>/2024/04/16/AXI/</url>
      
        <content type="html"><![CDATA[<h1 id="AXI协议特点"><a href="#AXI协议特点" class="headerlink" title="AXI协议特点"></a>AXI协议特点</h1><ul><li>高性能、高带宽、低延迟的片内总线</li><li>总线的地址&#x2F;控制和数据通道是分离的</li><li>支持不对齐的数据传输</li><li>支持突发传输，突发传输过程中只需要首地址</li><li>具有分离的读&#x2F;写数据通道</li><li>支持显著传输访问和乱序访问</li><li>更加容易进行时序收敛</li></ul><h1 id="AXI协议的接口"><a href="#AXI协议的接口" class="headerlink" title="AXI协议的接口"></a>AXI协议的接口</h1><ul><li><p>AXI4：高性能存储映射接口(存储映射（Meamory Map）：如果一个协议是存储映射的，那么主机所发出的会话（无论读或写）就会标明一个地址。这个地址对应于系统存储空间中的一个地址，表明是针对该存储空间的读写操作) </p></li><li><p>AXI4-Lite：简化版的 AXI4 接口，用于较少数据量的存储映射通信（AXI-Lite为外设提供单个数据传输，主要用于访问一些低速外设中的寄存器）</p></li><li><p>AXI4-Stream：用于高速数据流传输，非存储映射接口（AXI-Stream 接口则像 FIFO 一样，数据传输时不需要地址，在主从设备之间直接连续读写数据，主要用于如视频、高速 AD、PCIe、DMA 接口等需要高速数据传输的场合。</p><p>  ）</p></li></ul><h1 id="PS与PL之间的AXI接口"><a href="#PS与PL之间的AXI接口" class="headerlink" title="PS与PL之间的AXI接口"></a>PS与PL之间的AXI接口</h1><img src="/images/AXI/image-20240416101144741.png" alt="image-20240416101144741" style="zoom:67%;" /><img src="/images/AXI/image-20240416101224668.png" alt="image-20240416101224668" style="zoom:67%;" /><ul><li><p>PS 和 PL 之间的 9 个 AXI 接口可以分成三种类型</p><p>  通用 AXI：一条 32 位数据总线，适合 PL 和 PS 之间的中低速通信。四个接口：两个 PS 做主机，另两个 PL 做主机。</p><p>  加速器一致性端口：在 PL 和 APU 内的 SCU 之间的单个异步连接，总线宽度为 64 位。这个端口用来实现 APU cache 和 PL 的单元之间的一致性。PL 是做主机。</p><h2 id="高性能端口：四个高性能-AXI-接口，带有-FIFO-缓冲来提供“批量”读写操作，并支持-PL-和-PS-中的存储器单元的高速率通信。数据宽度是-32-或-64-位，在所有四个接口中-PL-都是做主机。"><a href="#高性能端口：四个高性能-AXI-接口，带有-FIFO-缓冲来提供“批量”读写操作，并支持-PL-和-PS-中的存储器单元的高速率通信。数据宽度是-32-或-64-位，在所有四个接口中-PL-都是做主机。" class="headerlink" title="  高性能端口：四个高性能 AXI 接口，带有 FIFO 缓冲来提供“批量”读写操作，并支持 PL 和 PS 中的存储器单元的高速率通信。数据宽度是 32 或 64 位，在所有四个接口中 PL 都是做主机。  "></a>  高性能端口：四个高性能 AXI 接口，带有 FIFO 缓冲来提供“批量”读写操作，并支持 PL 和 PS 中的存储器单元的高速率通信。数据宽度是 32 或 64 位，在所有四个接口中 PL 都是做主机。  </h2><h2 id="（后续将更新AXI协议实践部分内容……）"><a href="#（后续将更新AXI协议实践部分内容……）" class="headerlink" title="  （后续将更新AXI协议实践部分内容……）  "></a>  （后续将更新AXI协议实践部分内容……）  </h2></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>FreeRTOS Study</title>
      <link href="/2024/04/12/FreeRTOS/"/>
      <url>/2024/04/12/FreeRTOS/</url>
      
        <content type="html"><![CDATA[<h1 id="FreeRTOS基础知识"><a href="#FreeRTOS基础知识" class="headerlink" title="FreeRTOS基础知识"></a>FreeRTOS基础知识</h1><h2 id="什么是-FreeRTOS"><a href="#什么是-FreeRTOS" class="headerlink" title="什么是 FreeRTOS?"></a>什么是 FreeRTOS?</h2><ul><li>实时操作系统</li></ul><h2 id="FreeRTOS-特点？"><a href="#FreeRTOS-特点？" class="headerlink" title="FreeRTOS 特点？"></a>FreeRTOS 特点？</h2><ul><li>内核支持抢占式、合作式和时间片调度</li><li>支持Corex-M系列</li><li>占用存储小，内核4k-9k字节</li><li>移植性能好</li><li>任务与任务、任务与中断之间可以使用任务通知、消息队列、二值信号量、数值型信<br>号量、递归互斥信号量和互斥信号量进行通信和同步</li><li>具有优先级继承特性的互斥信号量</li><li>任务数量不限、任务优先级不限</li></ul><h2 id="任务管理"><a href="#任务管理" class="headerlink" title="任务管理"></a>任务管理</h2><h3 id="任务函数"><a href="#任务函数" class="headerlink" title="任务函数"></a>任务函数</h3><ul><li>C语言实现</li><li>必须返回void，并且带有一个void指针参数</li><li>每个任务不允许以任何方式从函数内返回</li><li>可以创建多个任务，任务之间独立，有自己的栈空间，即使是任务嵌套也是有自己的栈空间</li></ul><img src="/images/FreeRTOS/image-20240413152524989.png" alt="image-20240413152524989" style="zoom: 67%;" /><h3 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h3><ul><li><p>API</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskCreate</span><span class="params">(TaskFunction_t pxTaskCode,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">uint16_t</span> usStackDepth,</span></span><br><span class="line"><span class="params"><span class="type">void</span> * <span class="type">const</span> pvParameters,</span></span><br><span class="line"><span class="params">UBaseType_t uxPriority,</span></span><br><span class="line"><span class="params">TaskHandle_t * <span class="type">const</span> pxCreatedTask )</span></span><br></pre></td></tr></table></figure></li><li><p>任务注意事项</p><p>  任务嵌套时，第一个任务使用开始任务，用于管理后续的业务任务，<strong>开始任务执行后，记得删除开始任务</strong>，防止多次调用创建多个业务任务导致报错。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建开始任务</span></span><br><span class="line">   xTaskCreate((TaskFunction_t )start_task,            <span class="comment">//任务函数</span></span><br><span class="line">               (<span class="type">const</span> <span class="type">char</span>*    )<span class="string">&quot;start_task&quot;</span>,          <span class="comment">//任务名称</span></span><br><span class="line">               (<span class="type">uint16_t</span>       )START_STK_SIZE,        <span class="comment">//任务堆栈大小</span></span><br><span class="line">               (<span class="type">void</span>*          )<span class="literal">NULL</span>,                  <span class="comment">//传递给任务函数的参数</span></span><br><span class="line">               (UBaseType_t    )<span class="number">1</span>,       <span class="comment">//任务优先级</span></span><br><span class="line">               (TaskHandle_t*  )&amp;StartTask_Handler);   <span class="comment">//任务句柄              </span></span><br><span class="line">   <span class="comment">//开始任务任务函数</span></span><br><span class="line">   <span class="type">void</span> <span class="title function_">start_task</span><span class="params">(<span class="type">void</span> *pvParameters)</span></span><br><span class="line">&#123;  </span><br><span class="line">       <span class="comment">// 使用相同的任务函数，创建不同的任务实例吗，执行不同的操作</span></span><br><span class="line">       <span class="comment">// 注意二者的优先级是一致的</span></span><br><span class="line">   xTaskCreate((TaskFunction_t )print_task,     </span><br><span class="line">               (<span class="type">const</span> <span class="type">char</span>*    )<span class="string">&quot;print_task&quot;</span>,   </span><br><span class="line">               (<span class="type">uint16_t</span>       )<span class="number">1000</span>, </span><br><span class="line">               (<span class="type">void</span>*          )pcTextForTask1,</span><br><span class="line">               (UBaseType_t    )<span class="number">2</span>,</span><br><span class="line">               <span class="literal">NULL</span>);         </span><br><span class="line">   </span><br><span class="line">   xTaskCreate((TaskFunction_t )print_task,     </span><br><span class="line">               (<span class="type">const</span> <span class="type">char</span>*    )<span class="string">&quot;print_task&quot;</span>,   </span><br><span class="line">               (<span class="type">uint16_t</span>       )<span class="number">1000</span>, </span><br><span class="line">               (<span class="type">void</span>*          )pcTextForTask2,</span><br><span class="line">               (UBaseType_t    )<span class="number">2</span>,</span><br><span class="line">               <span class="literal">NULL</span>);         </span><br><span class="line">   vTaskDelete(StartTask_Handler); <span class="comment">//删除开始任务</span></span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">//通用打印字符任务函数，根据传入参数选择打印内容</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_task</span><span class="params">(<span class="type">void</span> *pvParameters)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span> *pcTaskName;</span><br><span class="line">   pcTaskName = (<span class="type">char</span> *)pvParameters;</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, pcTaskName);</span><br><span class="line">       delay_us(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>任务优先级</p><p>  <strong>低优先级号表示任务的优先级低，优先级号 0 表示最低优先级</strong>。有效的优先级号范围从 0 到(configMAX_PRIORITES – 1)。如果被选中的优先级上具有不止一个任务，调度器会让这些任务轮流执行。</p></li><li><p>任务状态</p><p>  <strong>调度器总是选择具有最高优先级的可运行任务来执行</strong>，如果只有运行态和非运行态两种状态，可能会导致低优先级的任务不会被执行（被饿死）。因此引入事件驱动，一个事件驱动任务只会在事件发生后触发工作(处理)，而在事件没有发生时是不能进入运行态的，<strong>调度器总是选择所有能够进入运行态的任务中具有最高优先级的任务</strong>。<strong>一个高优先级但</strong><br>  <strong>不能够运行的任务意味着不会被调度器选中，而代之以另一个优先级虽然更低但能够运行的任务。</strong>因此，<strong>采用事件驱动任务的意义就在于任务可以被创建在许多不同的优先级上，并且最高优先级任务不会把所有的低优先级任务饿死。</strong></p><p>  <strong>阻塞状态</strong></p><p>  任务可以进入阻塞态以等待以下两种不同类型的事件：</p><ol><li>定时(时间相关)事件——这类事件可以是延迟到期或是绝对时间到点。比如<br> 说某个任务可以进入阻塞态以延迟 10ms。</li><li>同步事件——源于其它任务或中断的事件。比如说，某个任务可以进入阻塞<br> 态以等待队列中有数据到来。同步事件囊括了所有板级范围内的事件类型。</li></ol><p>  <strong>挂起状态</strong></p><p>  挂起后的任务对于调度器来说是不可见的。</p><p>  <strong>就绪状态</strong></p><p>  如果任务处于非运行状态，但既没有阻塞也没有挂起，则这个任务处于就绪(ready，准备或就绪)状态。处于就绪态的任务能够被运行，但只是“准备(ready)”运行，而当前尚未运行。</p></li></ul><img src="/images/FreeRTOS/image-20240414163317855.png" alt="image-20240414163317855" style="zoom: 67%;" /><p>​&lt; 任务状态机 &gt;</p><ul><li><p>错误使用优先级代码</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*问题描述：开始任务优先级为1，开启任务调度后，开始任务开始工作，首先创建一个任务优先级为2的任务，cpu将会执行高优先级的任务，导致开始任务后续代码得不到cpu的使用权，从而使任务优先级为2的任务一直执行，导致其它任务饿死</span></span><br><span class="line"><span class="comment">*解决方法：开始任务优先级设置高一点，使其一直执行，并且在开始任务执行后删除自身，使创建的任务开始执行。如果具有相同的优先级，还要记得使用延时函数进行阻塞。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建开始任务</span></span><br><span class="line">    xTaskCreate((TaskFunction_t)start_task,             <span class="comment">//任务函数</span></span><br><span class="line">                (<span class="type">const</span> <span class="type">char</span> *)<span class="string">&quot;start_task&quot;</span>,             <span class="comment">//任务名称</span></span><br><span class="line">                (<span class="type">uint16_t</span>)START_STK_SIZE,               <span class="comment">//任务堆栈大小</span></span><br><span class="line">                (<span class="type">void</span> *)<span class="literal">NULL</span>,                           <span class="comment">//传递给任务函数的参数</span></span><br><span class="line">                (UBaseType_t)<span class="number">1</span>,           <span class="comment">//任务优先级</span></span><br><span class="line">                (TaskHandle_t *)&amp;StartTask_Handler);    <span class="comment">//任务句柄</span></span><br><span class="line"></span><br><span class="line">    vTaskStartScheduler();          <span class="comment">//开启任务调度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始任务任务函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">start_task</span><span class="params">(<span class="type">void</span> *pvParameters)</span></span><br><span class="line">&#123;</span><br><span class="line">    xTaskCreate((TaskFunction_t)print_task,</span><br><span class="line">                (<span class="type">const</span> <span class="type">char</span> *)<span class="string">&quot;print_task&quot;</span>,</span><br><span class="line">                (<span class="type">uint16_t</span>)<span class="number">1000</span>,</span><br><span class="line">                (<span class="type">void</span> *)pcTextForTask1,</span><br><span class="line">                (UBaseType_t)<span class="number">2</span>,</span><br><span class="line">                <span class="literal">NULL</span>);</span><br><span class="line">                </span><br><span class="line">    xTaskCreate((TaskFunction_t)print_task,</span><br><span class="line">                (<span class="type">const</span> <span class="type">char</span> *)<span class="string">&quot;print_task&quot;</span>,</span><br><span class="line">                (<span class="type">uint16_t</span>)<span class="number">1000</span>,</span><br><span class="line">                (<span class="type">void</span> *)pcTextForTask2,</span><br><span class="line">                (UBaseType_t)<span class="number">3</span>,</span><br><span class="line">                <span class="literal">NULL</span>);</span><br><span class="line">                </span><br><span class="line">    vTaskDelete(StartTask_Handler); <span class="comment">//删除开始任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>延时函数</p><p>  vTaskDelay()和vTaskDelayUntil()：这两个延时函数和自己实现的延时函数不同，这两个延时函数一旦被调用，当前任务会立马进入阻塞状态，而自己写的延时函数(以for循环等形式实现的软件延时)会被当做有效任务而一直执行。</p><p>  相对延时是指每次延时都是从任务执行函数vTaskDelay()开始，延时指定的时间结束；<br>  绝对延时是指每隔指定的时间，执行一次调用vTaskDelayUntil()函数的任务。换句话说：任务以固定的频率执行。</p><p>  参考链接：<a href="https://www.zhangshengrong.com/p/RmNP8lprNk/">FreeRTOS进阶之系统延时完全解析 &#x2F; 张生荣 (zhangshengrong.com)</a></p></li></ul><h3 id="空闲任务"><a href="#空闲任务" class="headerlink" title="空闲任务"></a>空闲任务</h3><ul><li><p>空闲任务拥有最低优先级(优先级 0)以保证其不会妨碍具有更高优先级的应用任务进入运行态</p></li><li><p>空闲任务的责任是要将分配给已删除任务的内存释放掉</p>  <img src="/images/FreeRTOS/image-20240415115440911.png" alt="image-20240415115440911" style="zoom:67%;" />  <img src="/images/FreeRTOS/image-20240415115414443.png" alt="image-20240415115414443" style="zoom:67%;" /></li></ul><h3 id="改变优先级"><a href="#改变优先级" class="headerlink" title="改变优先级"></a>改变优先级</h3><ul><li><p>vTaskPrioritySet()用于在调度器启动后改变任何任务的优先级</p></li><li><p>uxTaskPriorityGet() 用于查询一个任务的优先级</p></li></ul><h3 id="删除任务"><a href="#删除任务" class="headerlink" title="删除任务"></a>删除任务</h3><ul><li>当一个正在运行的任务调用了<strong>vTaskDelete</strong>(NULL)删除自己时，<strong>只会将任务的从列表(就绪，阻塞，挂起和事件链表)中移除，而任务结构体TCB与栈会交给空闲任务去释放，这样才算完成任务的删除</strong></li></ul><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><ul><li><p><strong>优先级抢占式调度</strong></p><p>  <img src="/images/FreeRTOS/image-20240415155457216.png" alt="image-20240415155457216"></p></li><li><p>协作式调度</p><p>  只可能在运行态任务进入阻塞态或是运行态任务显式调用 taskYIELD()时，才会进行上下文切换。任务永远不会被抢占，而具有相同优先级的任务也不会自动共享处理器时间。协作式调度的这作工作方式虽然比较简单，但可能会导致系统响应不够快。</p></li></ul><h2 id="FreeRTOS系统配置"><a href="#FreeRTOS系统配置" class="headerlink" title="FreeRTOS系统配置"></a>FreeRTOS系统配置</h2><ul><li><p>FreeRTOS 的系统配置文件为 FreeRTOSConfig.h，可通过此文件完成系统配置和裁剪</p></li><li><p>栈溢出检测方法：</p><p>  ​<strong>钩子函数</strong></p><p>  ​<code>vApplicationStackOverflowHook( ( TaskHandle_t ) pxCurrentTCB, pxCurrentTCB-&gt;pcTaskName );</code>通过参数<code>pxCurrentTCB</code>和<code>pcTaskName </code>，开发者可以确定是哪个任务堆栈发生溢出，从而进行相应处理。需要注意的是，<strong>根据堆栈的溢出程度不同，这些参数本身可能也是不正确的</strong>，在这种情况下可以通过访问当前任务控制块<code>pxCurrentTCB</code>来获取堆栈溢出任务信息。</p><p>  ​<strong>每个任务都有自己的堆栈</strong></p><p>  ​（1）使用<code>xTaskCreate()</code>创建，则任务堆栈会自动从堆内存上创建；</p><p>  ​（2）使用<code>xTaskCreateStatic()</code>创建，则堆栈由开发者自己确定并提供。</p><p>  ​<strong>检测方法</strong></p><p>  ​（1）上下文切换时将会占用较多的堆栈，该方法通过不断检测堆栈指针是否指向有效空间，来确定是否溢出。<strong>在堆栈中，portSTACK_GROWTH确定栈增长的方向，指针会从高地址开始指向堆栈的顶部，然后随着堆栈的使用而递减</strong>，因此<code>pxCurrentTCB-&gt;pxTopOfStack &gt; pxCurrentTCB-&gt;pxStack</code>时，才表明发生栈溢出，之后调用钩子函数，通过<code>( TaskHandle_t ) pxCurrentTCB, pxCurrentTCB-&gt;pcTaskName</code>参数，可以确定哪个任务出现堆栈溢出。优缺点：检测快，检测不全。</p>  <img src="/images/FreeRTOS/image-20240413145357135.png" alt="image-20240413145357135" style="zoom:50%;" />  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span>( ( configCHECK_FOR_STACK_OVERFLOW == 1 ) &amp;&amp; ( portSTACK_GROWTH &lt; 0 ) )</span></span><br><span class="line"><span class="comment">/* Only the current stack state is to be checked. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> taskCHECK_FOR_STACK_OVERFLOW()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Is the currently saved stack pointer within the stack limit? */</span></span><br><span class="line"><span class="keyword">if</span>( pxCurrentTCB-&gt;pxTopOfStack &lt;= pxCurrentTCB-&gt;pxStack ) <span class="comment">// 从高到低增长</span></span><br><span class="line">&#123;</span><br><span class="line">vApplicationStackOverflowHook( ( TaskHandle_t ) pxCurrentTCB, pxCurrentTCB-&gt;pcTaskName );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configCHECK_FOR_STACK_OVERFLOW == 1 */</span></span></span><br><span class="line"></span><br><span class="line">or：</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span>( ( configCHECK_FOR_STACK_OVERFLOW == 1 ) &amp;&amp; ( portSTACK_GROWTH &gt; 0 ) ) <span class="comment">// 从低到高增长</span></span></span><br><span class="line"><span class="comment">/* Only the current stack state is to be checked. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> taskCHECK_FOR_STACK_OVERFLOW()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Is the currently saved stack pointer within the stack limit? */</span></span><br><span class="line"><span class="keyword">if</span>( pxCurrentTCB-&gt;pxTopOfStack &gt;= pxCurrentTCB-&gt;pxEndOfStack )</span><br><span class="line">&#123;</span><br><span class="line">vApplicationStackOverflowHook( ( TaskHandle_t ) pxCurrentTCB, pxCurrentTCB-&gt;pcTaskName );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configCHECK_FOR_STACK_OVERFLOW == 1 */</span></span></span><br></pre></td></tr></table></figure><p>  ​（2）在创建任务的时候会向任务堆栈填充一个已知的标记值，方法二会一直检测堆栈后面的几个 bytes(标记值)是否被改写，如果被改写的话就会调用堆栈溢出钩子函数。<strong>堆栈从高到低增长，则检测高地址上的标记值；堆栈从低到高增长，则检测低地址上的标记值。</strong></p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span>( ( configCHECK_FOR_STACK_OVERFLOW &gt; 1 ) &amp;&amp; ( portSTACK_GROWTH &lt; 0 ) )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> taskCHECK_FOR_STACK_OVERFLOW()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">uint32_t</span> * <span class="type">const</span> pulStack = ( <span class="type">uint32_t</span> * ) pxCurrentTCB-&gt;pxStack;</span><br><span class="line"><span class="type">const</span> <span class="type">uint32_t</span> ulCheckValue = ( <span class="type">uint32_t</span> ) <span class="number">0xa5a5a5a5</span>;</span><br><span class="line"><span class="keyword">if</span>( ( pulStack[ <span class="number">0</span> ] != ulCheckValue ) ||</span><br><span class="line">( pulStack[ <span class="number">1</span> ] != ulCheckValue ) ||</span><br><span class="line">( pulStack[ <span class="number">2</span> ] != ulCheckValue ) ||</span><br><span class="line">( pulStack[ <span class="number">3</span> ] != ulCheckValue ) )</span><br><span class="line">&#123;</span><br><span class="line">vApplicationStackOverflowHook( ( TaskHandle_t ) pxCurrentTCB, pxCurrentTCB-&gt;pcTaskName );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* #if( configCHECK_FOR_STACK_OVERFLOW &gt; 1 ) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span>( ( configCHECK_FOR_STACK_OVERFLOW &gt; 1 ) &amp;&amp; ( portSTACK_GROWTH &gt; 0 ) )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> taskCHECK_FOR_STACK_OVERFLOW()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int8_t</span> *pcEndOfStack = ( <span class="type">int8_t</span> * ) pxCurrentTCB-&gt;pxEndOfStack;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint8_t</span> ucExpectedStackBytes[] = &#123;tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE,</span><br><span class="line">tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE,</span><br><span class="line">tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE,</span><br><span class="line">tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE,</span><br><span class="line">tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE &#125;;</span><br><span class="line">pcEndOfStack -= <span class="keyword">sizeof</span>( ucExpectedStackBytes );</span><br><span class="line"><span class="comment">/* Has the extremity of the task stack ever been written over? */</span></span><br><span class="line"><span class="keyword">if</span>( <span class="built_in">memcmp</span>( ( <span class="type">void</span> * ) pcEndOfStack, ( <span class="type">void</span> * ) ucExpectedStackBytes, \</span><br><span class="line"><span class="keyword">sizeof</span>( ucExpectedStackBytes) ) != <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">vApplicationStackOverflowHook( ( TaskHandle_t ) pxCurrentTCB, pxCurrentTCB-&gt;pcTaskName );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="多任务系统"><a href="#多任务系统" class="headerlink" title="多任务系统"></a>多任务系统</h2><img src="../images/FreeRTOS/image-20240422161025329.png" alt="image-20240422161025329" style="zoom:50%;" /><img src="../images/FreeRTOS/image-20240422161112764.png" alt="image-20240422161112764" style="zoom:50%;" /><h1 id="队列管理"><a href="#队列管理" class="headerlink" title="队列管理"></a>队列管理</h1><h2 id="队列基础知识"><a href="#队列基础知识" class="headerlink" title="队列基础知识"></a>队列基础知识</h2><ul><li><p><strong>FreeRTOS 中所有的通信与同步机制都是基于队列实现的</strong></p><p>  <img src="/images/FreeRTOS/image-20240418104536691.png" alt="image-20240418104536691"></p><p>  ​&lt;队列读写过程&gt;</p></li></ul><h2 id="队列函数"><a href="#队列函数" class="headerlink" title="队列函数"></a>队列函数</h2><ul><li><p>xQueueCreate() </p><p>  xQueueCreate()用于创建一个队列，并返回一个 xQueueHandle 句柄以便于对其创建的队列进行引用</p></li><li><p>xQueueSendToBack() 与 xQueueSendToFront() </p><p>  xQueueSendToBack()用于将数据发送到队列尾；而 xQueueSendToFront()用于将数据发送到队列首（但切记不要在中断服务例程中调用 xQueueSendToFront() 或xQueueSendToBack()，系统提供中断安全版本的xQueueSendToFrontFromISR()与xQueueSendToBackFromISR()用于在中断服务中实现相同的功能）</p></li><li><p>xQueueReceive()与 xQueuePeek() </p><p>  xQueueReceive()用于从队列中接收(读取）数据单元，<strong>接收到的单元同时会从队列中删除</strong>；xQueuePeek()也是从从队列中接收数据单元，不同的是并不从队列中删出接收到的单元。xQueuePeek()从队列首接收到数据后，<strong>不会修改队列中的数据</strong>，也不会改变数据在队列中的存储顺序。（中断安全版本的替代 API 函数xQueueReceiveFromISR()）</p></li><li><p>uxQueueMessagesWaiting()</p><p>  uxQueueMessagesWaiting()用于查询队列中当前有效数据单元个数；（在中断服务中使用其中断安全版本 uxQueueMessagesWaitingFromISR()）</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 写任务优先级小于读任务优先级，结果是队列中只要有数据，就会被读取走 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">long</span> writeData01 = <span class="number">100</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">long</span> writeData02 = <span class="number">200</span>;</span><br><span class="line"><span class="comment">// 队列</span></span><br><span class="line">QueueHandle_t myQueue;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建队列</span></span><br><span class="line">    myQueue = xQueueCreate(<span class="number">10</span>, <span class="keyword">sizeof</span>(<span class="type">long</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建开始任务</span></span><br><span class="line">    xTaskCreate((TaskFunction_t)start_task,             <span class="comment">//任务函数</span></span><br><span class="line">                (<span class="type">const</span> <span class="type">char</span> *)<span class="string">&quot;start_task&quot;</span>,             <span class="comment">//任务名称</span></span><br><span class="line">                (<span class="type">uint16_t</span>)START_STK_SIZE,               <span class="comment">//任务堆栈大小</span></span><br><span class="line">                (<span class="type">void</span> *)<span class="literal">NULL</span>,                           <span class="comment">//传递给任务函数的参数</span></span><br><span class="line">                (UBaseType_t)<span class="number">10</span>,           <span class="comment">//任务优先级</span></span><br><span class="line">                (TaskHandle_t *)&amp;StartTask_Handler);    <span class="comment">//任务句柄</span></span><br><span class="line">    </span><br><span class="line">    vTaskStartScheduler();          <span class="comment">//开启任务调度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始任务任务函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">start_task</span><span class="params">(<span class="type">void</span> *pvParameters)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (myQueue != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        xTaskCreate((TaskFunction_t)write_queue_task,</span><br><span class="line">                (<span class="type">const</span> <span class="type">char</span> *)<span class="string">&quot;write_queue_task01&quot;</span>,</span><br><span class="line">                (<span class="type">uint16_t</span>)<span class="number">1000</span>,</span><br><span class="line">                (<span class="type">void</span> *)writeData01,</span><br><span class="line">                (UBaseType_t)<span class="number">3</span>,</span><br><span class="line">                (TaskHandle_t *)&amp;write_queue_task01);    <span class="comment">//任务句柄</span></span><br><span class="line"></span><br><span class="line">    xTaskCreate((TaskFunction_t)write_queue_task,</span><br><span class="line">                (<span class="type">const</span> <span class="type">char</span> *)<span class="string">&quot;write_queue_task02&quot;</span>,</span><br><span class="line">                (<span class="type">uint16_t</span>)<span class="number">1000</span>,</span><br><span class="line">                (<span class="type">void</span> *)writeData02,</span><br><span class="line">                (UBaseType_t)<span class="number">3</span>,</span><br><span class="line">                (TaskHandle_t *)&amp;write_queue_task02);    <span class="comment">//任务句柄</span></span><br><span class="line">                </span><br><span class="line">    xTaskCreate((TaskFunction_t)read_queue_task,</span><br><span class="line">                (<span class="type">const</span> <span class="type">char</span> *)<span class="string">&quot;read_queue_task&quot;</span>,</span><br><span class="line">                (<span class="type">uint16_t</span>)<span class="number">1000</span>,</span><br><span class="line">                (<span class="type">void</span> *)<span class="literal">NULL</span>,</span><br><span class="line">                (UBaseType_t)<span class="number">4</span>,</span><br><span class="line">                (TaskHandle_t *)&amp;read_queue_task01);    <span class="comment">//任务句柄</span></span><br><span class="line">    &#125;</span><br><span class="line">    vTaskDelete(StartTask_Handler); <span class="comment">//删除开始任务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写队列任务函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_queue_task</span><span class="params">(<span class="type">void</span> *pvParameters)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> tempWriteData;</span><br><span class="line">    BaseType_t returnState;</span><br><span class="line">    tempWriteData = (<span class="type">long</span>)pvParameters;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        returnState = xQueueSendToBack(myQueue, &amp;tempWriteData, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (returnState != pdPASS)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Write Data errQUEUE_FULL!\r\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读队列任务函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_queue_task</span><span class="params">(<span class="type">void</span> *pvParameters)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> destReadData;</span><br><span class="line">    BaseType_t returnResult;</span><br><span class="line">    <span class="type">const</span> portTickType xTicksToWait = <span class="number">100</span> / portTICK_RATE_MS; </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        returnResult = xQueueReceive(myQueue, &amp;destReadData, xTicksToWait);</span><br><span class="line">        <span class="keyword">if</span> (returnResult != pdPASS)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Read Data errQUEUE_FULL!\r\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Received: %ld\r\n&quot;</span>, destReadData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 写任务优先级大于读任务优先级，结果是队列中写任务轮流阻塞写入数据，读任务一直工作读取数据*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mainSENDER_1 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mainSENDER_2 2</span></span><br><span class="line"><span class="comment">// 队列</span></span><br><span class="line">QueueHandle_t myQueue;</span><br><span class="line"><span class="comment">/* 定义队列传递的结构类型。 */</span> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> ucValue; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> ucSource; </span><br><span class="line">&#125; xData; </span><br><span class="line"><span class="comment">/* 声明两个xData类型的变量，通过队列进行传递 */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">const</span> xData xStructsToSend[<span class="number">2</span>] = </span><br><span class="line">&#123; </span><br><span class="line">    &#123; <span class="number">100</span>, mainSENDER_1 &#125;, <span class="comment">/* Used by Sender1. */</span> </span><br><span class="line">    &#123; <span class="number">200</span>, mainSENDER_2 &#125;  <span class="comment">/* Used by Sender2. */</span> </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建队列</span></span><br><span class="line">    myQueue = xQueueCreate(<span class="number">3</span>, <span class="keyword">sizeof</span>(xData));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建开始任务</span></span><br><span class="line">    xTaskCreate((TaskFunction_t)start_task,             <span class="comment">//任务函数</span></span><br><span class="line">                (<span class="type">const</span> <span class="type">char</span> *)<span class="string">&quot;start_task&quot;</span>,             <span class="comment">//任务名称</span></span><br><span class="line">                (<span class="type">uint16_t</span>)START_STK_SIZE,               <span class="comment">//任务堆栈大小</span></span><br><span class="line">                (<span class="type">void</span> *)<span class="literal">NULL</span>,                           <span class="comment">//传递给任务函数的参数</span></span><br><span class="line">                (UBaseType_t)<span class="number">10</span>,           <span class="comment">//任务优先级</span></span><br><span class="line">                (TaskHandle_t *)&amp;StartTask_Handler);    <span class="comment">//任务句柄</span></span><br><span class="line">    </span><br><span class="line">    vTaskStartScheduler();          <span class="comment">//开启任务调度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始任务任务函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">start_task</span><span class="params">(<span class="type">void</span> *pvParameters)</span></span><br><span class="line">&#123;</span><br><span class="line">    xTaskCreate((TaskFunction_t)write_queue_task,</span><br><span class="line">                (<span class="type">const</span> <span class="type">char</span> *)<span class="string">&quot;write_queue_task01&quot;</span>,</span><br><span class="line">                (<span class="type">uint16_t</span>)<span class="number">1000</span>,</span><br><span class="line">                (<span class="type">void</span> *)&amp;(xStructsToSend[<span class="number">0</span>]),</span><br><span class="line">                (UBaseType_t)<span class="number">3</span>,</span><br><span class="line">                (TaskHandle_t *)&amp;write_queue_task01);    <span class="comment">//任务句柄</span></span><br><span class="line"></span><br><span class="line">    xTaskCreate((TaskFunction_t)write_queue_task,</span><br><span class="line">                (<span class="type">const</span> <span class="type">char</span> *)<span class="string">&quot;write_queue_task02&quot;</span>,</span><br><span class="line">                (<span class="type">uint16_t</span>)<span class="number">1000</span>,</span><br><span class="line">                (<span class="type">void</span> *)&amp;(xStructsToSend[<span class="number">1</span>]),</span><br><span class="line">                (UBaseType_t)<span class="number">3</span>,</span><br><span class="line">                (TaskHandle_t *)&amp;write_queue_task02);    <span class="comment">//任务句柄</span></span><br><span class="line">                </span><br><span class="line">    xTaskCreate((TaskFunction_t)read_queue_task,</span><br><span class="line">                (<span class="type">const</span> <span class="type">char</span> *)<span class="string">&quot;read_queue_task&quot;</span>,</span><br><span class="line">                (<span class="type">uint16_t</span>)<span class="number">1000</span>,</span><br><span class="line">                (<span class="type">void</span> *)<span class="literal">NULL</span>,</span><br><span class="line">                (UBaseType_t)<span class="number">2</span>,</span><br><span class="line">                (TaskHandle_t *)&amp;read_queue_task01);    <span class="comment">//任务句柄</span></span><br><span class="line"></span><br><span class="line">    vTaskDelete(StartTask_Handler); <span class="comment">//删除开始任务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写队列任务函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_queue_task</span><span class="params">(<span class="type">void</span> *pvParameters)</span></span><br><span class="line">&#123;</span><br><span class="line">    xData* tempWriteData;</span><br><span class="line">    BaseType_t returnState;</span><br><span class="line">    <span class="type">const</span> portTickType xTicksToWait = <span class="number">100</span> / portTICK_RATE_MS; </span><br><span class="line">    tempWriteData = pvParameters;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        returnState = xQueueSendToBack(myQueue, tempWriteData, xTicksToWait);</span><br><span class="line">        <span class="keyword">if</span> (returnState != pdPASS)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Write Data errQUEUE_FULL!\r\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读队列任务函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_queue_task</span><span class="params">(<span class="type">void</span> *pvParameters)</span></span><br><span class="line">&#123;</span><br><span class="line">    xData destReadData;</span><br><span class="line">    BaseType_t returnResult;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        returnResult = xQueueReceive(myQueue, &amp;destReadData, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (returnResult != pdPASS)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Read Data errQUEUE_FULL!\r\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (destReadData.ucSource == mainSENDER_1)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Received 1----%d\r\n&quot;</span>, destReadData.ucValue);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (destReadData.ucSource == mainSENDER_2)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Received 2----%d\r\n&quot;</span>, destReadData.ucValue);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;ERROR!\r\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="大数据量队列传输"><a href="#大数据量队列传输" class="headerlink" title="大数据量队列传输"></a>大数据量队列传输</h2><ul><li><p>如果队列存储的数据单元尺寸较大，<strong>利用队列来传递数据的指针而不是对数据本身在队列上一字节一字节地拷贝进或拷贝出。传递指针无论是在处理速度上还是内存空间利用上都更有效。</strong></p></li><li><p>指针操作时<strong>注意</strong>：</p><p>  （1）当任务间通过指针共享内存时，应该从根本上保证所不会有任意两个任务同时修改共享内存中的数据，或是以其它行为方式使得共享内存数据无效或产生一致性问题；共享内存在其指针发送到队列之前，其内容只允许被发送任务访问；共享内存指针从队列中被读出之后，其内容亦只允许被接收任务访问。</p><p>  （2）如果指针指向的内存空间是动态分配的，只应该有一个任务负责对其进行内存释放。当这段内存空间被释放之后，就不应该有任何一个任务再访问这段空间。</p><p>  （3）切忌用指针访问任务栈上分配的空间。因为当栈帧发生改变后，栈上的数据将不再有效。</p></li></ul><h1 id="中断管理"><a href="#中断管理" class="headerlink" title="中断管理"></a>中断管理</h1><h2 id="M3中断"><a href="#M3中断" class="headerlink" title="M3中断"></a>M3中断</h2><ul><li><p>Cotex-M3 的 NVIC 最多支持 240 个 IRQ(中断请求)、1 个不可屏蔽中断(NMI)、1 个 Systick(滴答定时器)定时器中断和多个系统异常</p></li><li><p>FreeRTOS 的中断配置没有处理亚优先级这种情况，所以只能配置为组 4，16 个优先级</p><p>  （1）<strong>中断优先级与任务优先级的区别</strong>？</p><ul><li>二者没有任何关系，不论中断优先级别是多少，中断优先级总是高于任务优先级，中断来了就开始执行中断服务程序</li><li>通常情况下，中断优先级数值越小，则优先级别越高；但是任务优先级越小，表明优先级别越低</li></ul></li><li><p>configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY（FreeRTOS可以管理的最大的优先级），可以自由设置，设置为 5也就是高于 5 的优先级(优先级数小于 5)不归 FreeRTOS 管理！</p></li><li><p>configKERNEL_INTERRUPT_PRIORITY（最小优先级）16 个优先级，0-15，不同MCU不同，根据芯片架构选择</p>  <img src="../images/FreeRTOS/image-20240422160631917.png" alt="image-20240422160631917" style="zoom:67%;" /></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello Tadeo!</title>
      <link href="/2024/04/11/Hello/"/>
      <url>/2024/04/11/Hello/</url>
      
        <content type="html"><![CDATA[<h1 id="欢迎来到Tadeo的博客空间！"><a href="#欢迎来到Tadeo的博客空间！" class="headerlink" title="欢迎来到Tadeo的博客空间！"></a>欢迎来到Tadeo的博客空间！</h1><h1 id="2024-04-11-这是我开始记录博客的时间！"><a href="#2024-04-11-这是我开始记录博客的时间！" class="headerlink" title="2024.04.11 这是我开始记录博客的时间！"></a>2024.04.11 这是我开始记录博客的时间！</h1><h1 id="加油！坚持下去！"><a href="#加油！坚持下去！" class="headerlink" title="加油！坚持下去！"></a>加油！坚持下去！</h1>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
