<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>AXI协议</title>
      <link href="/2024/04/16/AXI/"/>
      <url>/2024/04/16/AXI/</url>
      
        <content type="html"><![CDATA[<h1 id="AXI协议特点"><a href="#AXI协议特点" class="headerlink" title="AXI协议特点"></a>AXI协议特点</h1><ul><li>高性能、高带宽、低延迟的片内总线</li><li>总线的地址&#x2F;控制和数据通道是分离的</li><li>支持不对齐的数据传输</li><li>支持突发传输，突发传输过程中只需要首地址</li><li>具有分离的读&#x2F;写数据通道</li><li>支持显著传输访问和乱序访问</li><li>更加容易进行时序收敛</li></ul><h1 id="AXI协议的接口"><a href="#AXI协议的接口" class="headerlink" title="AXI协议的接口"></a>AXI协议的接口</h1><ul><li><p>AXI4：高性能存储映射接口(存储映射（Meamory Map）：如果一个协议是存储映射的，那么主机所发出的会话（无论读或写）就会标明一个地址。这个地址对应于系统存储空间中的一个地址，表明是针对该存储空间的读写操作) </p></li><li><p>AXI4-Lite：简化版的 AXI4 接口，用于较少数据量的存储映射通信（AXI-Lite为外设提供单个数据传输，主要用于访问一些低速外设中的寄存器）</p></li><li><p>AXI4-Stream：用于高速数据流传输，非存储映射接口（AXI-Stream 接口则像 FIFO 一样，数据传输时不需要地址，在主从设备之间直接连续读写数据，主要用于如视频、高速 AD、PCIe、DMA 接口等需要高速数据传输的场合。</p><p>  ）</p></li></ul><h1 id="PS与PL之间的AXI接口"><a href="#PS与PL之间的AXI接口" class="headerlink" title="PS与PL之间的AXI接口"></a>PS与PL之间的AXI接口</h1><img src="/images/AXI/image-20240416101144741.png" alt="image-20240416101144741" style="zoom:67%;" /><img src="/images/AXI/image-20240416101224668.png" alt="image-20240416101224668" style="zoom:67%;" /><ul><li><p>PS 和 PL 之间的 9 个 AXI 接口可以分成三种类型</p><p>  通用 AXI：一条 32 位数据总线，适合 PL 和 PS 之间的中低速通信。四个接口：两个 PS 做主机，另两个 PL 做主机。</p><p>  加速器一致性端口：在 PL 和 APU 内的 SCU 之间的单个异步连接，总线宽度为 64 位。这个端口用来实现 APU cache 和 PL 的单元之间的一致性。PL 是做主机。</p><p>  高性能端口：四个高性能 AXI 接口，带有 FIFO 缓冲来提供“批量”读写操作，并支持 PL 和 PS 中的存储器单元的高速率通信。数据宽度是 32 或 64 位，在所有四个接口中 PL 都是做主机。</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>FreeRTOS Study</title>
      <link href="/2024/04/12/FreeRTOS/"/>
      <url>/2024/04/12/FreeRTOS/</url>
      
        <content type="html"><![CDATA[<h1 id="FreeRTOS基础知识"><a href="#FreeRTOS基础知识" class="headerlink" title="FreeRTOS基础知识"></a>FreeRTOS基础知识</h1><h2 id="什么是-FreeRTOS"><a href="#什么是-FreeRTOS" class="headerlink" title="什么是 FreeRTOS?"></a>什么是 FreeRTOS?</h2><ul><li>实时操作系统</li></ul><h2 id="FreeRTOS-特点？"><a href="#FreeRTOS-特点？" class="headerlink" title="FreeRTOS 特点？"></a>FreeRTOS 特点？</h2><ul><li>内核支持抢占式、合作式和时间片调度</li><li>支持Corex-M系列</li><li>占用存储小，内核4k-9k字节</li><li>移植性能好</li><li>任务与任务、任务与中断之间可以使用任务通知、消息队列、二值信号量、数值型信<br>号量、递归互斥信号量和互斥信号量进行通信和同步</li><li>具有优先级继承特性的互斥信号量</li><li>任务数量不限、任务优先级不限</li></ul><h2 id="任务管理"><a href="#任务管理" class="headerlink" title="任务管理"></a>任务管理</h2><h3 id="任务函数"><a href="#任务函数" class="headerlink" title="任务函数"></a>任务函数</h3><ul><li>C语言实现</li><li>必须返回void，并且带有一个void指针参数</li><li>每个任务不允许以任何方式从函数内返回</li><li>可以创建多个任务，任务之间独立，有自己的栈空间，即使是任务嵌套也是有自己的栈空间</li></ul><img src="/images/FreeRTOS/image-20240413152524989.png" alt="image-20240413152524989" style="zoom: 67%;" /><h3 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h3><ul><li><p>API</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskCreate</span><span class="params">(TaskFunction_t pxTaskCode,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">uint16_t</span> usStackDepth,</span></span><br><span class="line"><span class="params"><span class="type">void</span> * <span class="type">const</span> pvParameters,</span></span><br><span class="line"><span class="params">UBaseType_t uxPriority,</span></span><br><span class="line"><span class="params">TaskHandle_t * <span class="type">const</span> pxCreatedTask )</span></span><br></pre></td></tr></table></figure></li><li><p>任务注意事项</p><p>  任务嵌套时，第一个任务使用开始任务，用于管理后续的业务任务，<strong>开始任务执行后，记得删除开始任务</strong>，防止多次调用创建多个业务任务导致报错。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建开始任务</span></span><br><span class="line">   xTaskCreate((TaskFunction_t )start_task,            <span class="comment">//任务函数</span></span><br><span class="line">               (<span class="type">const</span> <span class="type">char</span>*    )<span class="string">&quot;start_task&quot;</span>,          <span class="comment">//任务名称</span></span><br><span class="line">               (<span class="type">uint16_t</span>       )START_STK_SIZE,        <span class="comment">//任务堆栈大小</span></span><br><span class="line">               (<span class="type">void</span>*          )<span class="literal">NULL</span>,                  <span class="comment">//传递给任务函数的参数</span></span><br><span class="line">               (UBaseType_t    )<span class="number">1</span>,       <span class="comment">//任务优先级</span></span><br><span class="line">               (TaskHandle_t*  )&amp;StartTask_Handler);   <span class="comment">//任务句柄              </span></span><br><span class="line">   <span class="comment">//开始任务任务函数</span></span><br><span class="line">   <span class="type">void</span> <span class="title function_">start_task</span><span class="params">(<span class="type">void</span> *pvParameters)</span></span><br><span class="line">&#123;  </span><br><span class="line">       <span class="comment">// 使用相同的任务函数，创建不同的任务实例吗，执行不同的操作</span></span><br><span class="line">       <span class="comment">// 注意二者的优先级是一致的</span></span><br><span class="line">   xTaskCreate((TaskFunction_t )print_task,     </span><br><span class="line">               (<span class="type">const</span> <span class="type">char</span>*    )<span class="string">&quot;print_task&quot;</span>,   </span><br><span class="line">               (<span class="type">uint16_t</span>       )<span class="number">1000</span>, </span><br><span class="line">               (<span class="type">void</span>*          )pcTextForTask1,</span><br><span class="line">               (UBaseType_t    )<span class="number">2</span>,</span><br><span class="line">               <span class="literal">NULL</span>);         </span><br><span class="line">   </span><br><span class="line">   xTaskCreate((TaskFunction_t )print_task,     </span><br><span class="line">               (<span class="type">const</span> <span class="type">char</span>*    )<span class="string">&quot;print_task&quot;</span>,   </span><br><span class="line">               (<span class="type">uint16_t</span>       )<span class="number">1000</span>, </span><br><span class="line">               (<span class="type">void</span>*          )pcTextForTask2,</span><br><span class="line">               (UBaseType_t    )<span class="number">2</span>,</span><br><span class="line">               <span class="literal">NULL</span>);         </span><br><span class="line">   vTaskDelete(StartTask_Handler); <span class="comment">//删除开始任务</span></span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">//通用打印字符任务函数，根据传入参数选择打印内容</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_task</span><span class="params">(<span class="type">void</span> *pvParameters)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span> *pcTaskName;</span><br><span class="line">   pcTaskName = (<span class="type">char</span> *)pvParameters;</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, pcTaskName);</span><br><span class="line">       delay_us(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>任务优先级</p><p>  <strong>低优先级号表示任务的优先级低，优先级号 0 表示最低优先级</strong>。有效的优先级号范围从 0 到(configMAX_PRIORITES – 1)。如果被选中的优先级上具有不止一个任务，调度器会让这些任务轮流执行。</p></li><li><p>任务状态</p><p>  <strong>调度器总是选择具有最高优先级的可运行任务来执行</strong>，如果只有运行态和非运行态两种状态，可能会导致低优先级的任务不会被执行（被饿死）。因此引入事件驱动，一个事件驱动任务只会在事件发生后触发工作(处理)，而在事件没有发生时是不能进入运行态的，<strong>调度器总是选择所有能够进入运行态的任务中具有最高优先级的任务</strong>。<strong>一个高优先级但</strong><br>  <strong>不能够运行的任务意味着不会被调度器选中，而代之以另一个优先级虽然更低但能够运行的任务。</strong>因此，<strong>采用事件驱动任务的意义就在于任务可以被创建在许多不同的优先级上，并且最高优先级任务不会把所有的低优先级任务饿死。</strong></p><p>  <strong>阻塞状态</strong></p><p>  任务可以进入阻塞态以等待以下两种不同类型的事件：</p><ol><li>定时(时间相关)事件——这类事件可以是延迟到期或是绝对时间到点。比如<br> 说某个任务可以进入阻塞态以延迟 10ms。</li><li>同步事件——源于其它任务或中断的事件。比如说，某个任务可以进入阻塞<br> 态以等待队列中有数据到来。同步事件囊括了所有板级范围内的事件类型。</li></ol><p>  <strong>挂起状态</strong></p><p>  挂起后的任务对于调度器来说是不可见的。</p><p>  <strong>就绪状态</strong></p><p>  如果任务处于非运行状态，但既没有阻塞也没有挂起，则这个任务处于就绪(ready，准备或就绪)状态。处于就绪态的任务能够被运行，但只是“准备(ready)”运行，而当前尚未运行。</p></li></ul><img src="/images/FreeRTOS/image-20240414163317855.png" alt="image-20240414163317855" style="zoom: 67%;" /><p>​&lt; 任务状态机 &gt;</p><ul><li><p>错误使用优先级代码</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*问题描述：开始任务优先级为1，开启任务调度后，开始任务开始工作，首先创建一个任务优先级为2的任务，cpu将会执行高优先级的任务，导致开始任务后续代码得不到cpu的使用权，从而使任务优先级为2的任务一直执行，导致其它任务饿死</span></span><br><span class="line"><span class="comment">*解决方法：开始任务优先级设置高一点，使其一直执行，并且在开始任务执行后删除自身，使创建的任务开始执行。如果具有相同的优先级，还要记得使用延时函数进行阻塞。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建开始任务</span></span><br><span class="line">    xTaskCreate((TaskFunction_t)start_task,             <span class="comment">//任务函数</span></span><br><span class="line">                (<span class="type">const</span> <span class="type">char</span> *)<span class="string">&quot;start_task&quot;</span>,             <span class="comment">//任务名称</span></span><br><span class="line">                (<span class="type">uint16_t</span>)START_STK_SIZE,               <span class="comment">//任务堆栈大小</span></span><br><span class="line">                (<span class="type">void</span> *)<span class="literal">NULL</span>,                           <span class="comment">//传递给任务函数的参数</span></span><br><span class="line">                (UBaseType_t)<span class="number">1</span>,           <span class="comment">//任务优先级</span></span><br><span class="line">                (TaskHandle_t *)&amp;StartTask_Handler);    <span class="comment">//任务句柄</span></span><br><span class="line"></span><br><span class="line">    vTaskStartScheduler();          <span class="comment">//开启任务调度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始任务任务函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">start_task</span><span class="params">(<span class="type">void</span> *pvParameters)</span></span><br><span class="line">&#123;</span><br><span class="line">    xTaskCreate((TaskFunction_t)print_task,</span><br><span class="line">                (<span class="type">const</span> <span class="type">char</span> *)<span class="string">&quot;print_task&quot;</span>,</span><br><span class="line">                (<span class="type">uint16_t</span>)<span class="number">1000</span>,</span><br><span class="line">                (<span class="type">void</span> *)pcTextForTask1,</span><br><span class="line">                (UBaseType_t)<span class="number">2</span>,</span><br><span class="line">                <span class="literal">NULL</span>);</span><br><span class="line">                </span><br><span class="line">    xTaskCreate((TaskFunction_t)print_task,</span><br><span class="line">                (<span class="type">const</span> <span class="type">char</span> *)<span class="string">&quot;print_task&quot;</span>,</span><br><span class="line">                (<span class="type">uint16_t</span>)<span class="number">1000</span>,</span><br><span class="line">                (<span class="type">void</span> *)pcTextForTask2,</span><br><span class="line">                (UBaseType_t)<span class="number">3</span>,</span><br><span class="line">                <span class="literal">NULL</span>);</span><br><span class="line">                </span><br><span class="line">    vTaskDelete(StartTask_Handler); <span class="comment">//删除开始任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>延时函数</p><p>  vTaskDelay()和vTaskDelayUntil()：这两个延时函数和自己实现的延时函数不同，这两个延时函数一旦被调用，当前任务会立马进入阻塞状态，而自己写的延时函数(以for循环等形式实现的软件延时)会被当做有效任务而一直执行。</p><p>  相对延时是指每次延时都是从任务执行函数vTaskDelay()开始，延时指定的时间结束；<br>  绝对延时是指每隔指定的时间，执行一次调用vTaskDelayUntil()函数的任务。换句话说：任务以固定的频率执行。</p><p>  参考链接：<a href="https://www.zhangshengrong.com/p/RmNP8lprNk/">FreeRTOS进阶之系统延时完全解析 &#x2F; 张生荣 (zhangshengrong.com)</a></p></li></ul><h3 id="空闲任务"><a href="#空闲任务" class="headerlink" title="空闲任务"></a>空闲任务</h3><ul><li><p>空闲任务拥有最低优先级(优先级 0)以保证其不会妨碍具有更高优先级的应用任务进入运行态</p></li><li><p>空闲任务的责任是要将分配给已删除任务的内存释放掉</p>  <img src="/images/FreeRTOS/image-20240415115440911.png" alt="image-20240415115440911" style="zoom:67%;" />  <img src="/images/FreeRTOS/image-20240415115414443.png" alt="image-20240415115414443" style="zoom:67%;" /></li></ul><h3 id="改变优先级"><a href="#改变优先级" class="headerlink" title="改变优先级"></a>改变优先级</h3><ul><li><p>vTaskPrioritySet()用于在调度器启动后改变任何任务的优先级</p></li><li><p>uxTaskPriorityGet() 用于查询一个任务的优先级</p></li></ul><h3 id="删除任务"><a href="#删除任务" class="headerlink" title="删除任务"></a>删除任务</h3><ul><li>当一个正在运行的任务调用了<strong>vTaskDelete</strong>(NULL)删除自己时，<strong>只会将任务的从列表(就绪，阻塞，挂起和事件链表)中移除，而任务结构体TCB与栈会交给空闲任务去释放，这样才算完成任务的删除</strong></li></ul><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><ul><li><p><strong>优先级抢占式调度</strong></p><p>  <img src="/images/FreeRTOS/image-20240415155457216.png" alt="image-20240415155457216"></p></li><li><p>协作式调度</p><p>  只可能在运行态任务进入阻塞态或是运行态任务显式调用 taskYIELD()时，才会进行上下文切换。任务永远不会被抢占，而具有相同优先级的任务也不会自动共享处理器时间。协作式调度的这作工作方式虽然比较简单，但可能会导致系统响应不够快。</p></li></ul><h2 id="FreeRTOS系统配置"><a href="#FreeRTOS系统配置" class="headerlink" title="FreeRTOS系统配置"></a>FreeRTOS系统配置</h2><ul><li><p>FreeRTOS 的系统配置文件为 FreeRTOSConfig.h，可通过此文件完成系统配置和裁剪</p></li><li><p>栈溢出检测方法：</p><p>  ​<strong>钩子函数</strong></p><p>  ​<code>vApplicationStackOverflowHook( ( TaskHandle_t ) pxCurrentTCB, pxCurrentTCB-&gt;pcTaskName );</code>通过参数<code>pxCurrentTCB</code>和<code>pcTaskName </code>，开发者可以确定是哪个任务堆栈发生溢出，从而进行相应处理。需要注意的是，<strong>根据堆栈的溢出程度不同，这些参数本身可能也是不正确的</strong>，在这种情况下可以通过访问当前任务控制块<code>pxCurrentTCB</code>来获取堆栈溢出任务信息。</p><p>  ​<strong>每个任务都有自己的堆栈</strong></p><p>  ​（1）使用<code>xTaskCreate()</code>创建，则任务堆栈会自动从堆内存上创建；</p><p>  ​（2）使用<code>xTaskCreateStatic()</code>创建，则堆栈由开发者自己确定并提供。</p><p>  ​<strong>检测方法</strong></p><p>  ​（1）上下文切换时将会占用较多的堆栈，该方法通过不断检测堆栈指针是否指向有效空间，来确定是否溢出。<strong>在堆栈中，portSTACK_GROWTH确定栈增长的方向，指针会从高地址开始指向堆栈的顶部，然后随着堆栈的使用而递减</strong>，因此<code>pxCurrentTCB-&gt;pxTopOfStack &gt; pxCurrentTCB-&gt;pxStack</code>时，才表明发生栈溢出，之后调用钩子函数，通过<code>( TaskHandle_t ) pxCurrentTCB, pxCurrentTCB-&gt;pcTaskName</code>参数，可以确定哪个任务出现堆栈溢出。优缺点：检测快，检测不全。</p>  <img src="/images/FreeRTOS/image-20240413145357135.png" alt="image-20240413145357135" style="zoom:50%;" />  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span>( ( configCHECK_FOR_STACK_OVERFLOW == 1 ) &amp;&amp; ( portSTACK_GROWTH &lt; 0 ) )</span></span><br><span class="line"><span class="comment">/* Only the current stack state is to be checked. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> taskCHECK_FOR_STACK_OVERFLOW()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Is the currently saved stack pointer within the stack limit? */</span></span><br><span class="line"><span class="keyword">if</span>( pxCurrentTCB-&gt;pxTopOfStack &lt;= pxCurrentTCB-&gt;pxStack ) <span class="comment">// 从高到低增长</span></span><br><span class="line">&#123;</span><br><span class="line">vApplicationStackOverflowHook( ( TaskHandle_t ) pxCurrentTCB, pxCurrentTCB-&gt;pcTaskName );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configCHECK_FOR_STACK_OVERFLOW == 1 */</span></span></span><br><span class="line"></span><br><span class="line">or：</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span>( ( configCHECK_FOR_STACK_OVERFLOW == 1 ) &amp;&amp; ( portSTACK_GROWTH &gt; 0 ) ) <span class="comment">// 从低到高增长</span></span></span><br><span class="line"><span class="comment">/* Only the current stack state is to be checked. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> taskCHECK_FOR_STACK_OVERFLOW()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Is the currently saved stack pointer within the stack limit? */</span></span><br><span class="line"><span class="keyword">if</span>( pxCurrentTCB-&gt;pxTopOfStack &gt;= pxCurrentTCB-&gt;pxEndOfStack )</span><br><span class="line">&#123;</span><br><span class="line">vApplicationStackOverflowHook( ( TaskHandle_t ) pxCurrentTCB, pxCurrentTCB-&gt;pcTaskName );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configCHECK_FOR_STACK_OVERFLOW == 1 */</span></span></span><br></pre></td></tr></table></figure><p>  ​（2）在创建任务的时候会向任务堆栈填充一个已知的标记值，方法二会一直检测堆栈后面的几个 bytes(标记值)是否被改写，如果被改写的话就会调用堆栈溢出钩子函数。<strong>堆栈从高到低增长，则检测高地址上的标记值；堆栈从低到高增长，则检测低地址上的标记值。</strong></p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span>( ( configCHECK_FOR_STACK_OVERFLOW &gt; 1 ) &amp;&amp; ( portSTACK_GROWTH &lt; 0 ) )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> taskCHECK_FOR_STACK_OVERFLOW()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">uint32_t</span> * <span class="type">const</span> pulStack = ( <span class="type">uint32_t</span> * ) pxCurrentTCB-&gt;pxStack;</span><br><span class="line"><span class="type">const</span> <span class="type">uint32_t</span> ulCheckValue = ( <span class="type">uint32_t</span> ) <span class="number">0xa5a5a5a5</span>;</span><br><span class="line"><span class="keyword">if</span>( ( pulStack[ <span class="number">0</span> ] != ulCheckValue ) ||</span><br><span class="line">( pulStack[ <span class="number">1</span> ] != ulCheckValue ) ||</span><br><span class="line">( pulStack[ <span class="number">2</span> ] != ulCheckValue ) ||</span><br><span class="line">( pulStack[ <span class="number">3</span> ] != ulCheckValue ) )</span><br><span class="line">&#123;</span><br><span class="line">vApplicationStackOverflowHook( ( TaskHandle_t ) pxCurrentTCB, pxCurrentTCB-&gt;pcTaskName );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* #if( configCHECK_FOR_STACK_OVERFLOW &gt; 1 ) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span>( ( configCHECK_FOR_STACK_OVERFLOW &gt; 1 ) &amp;&amp; ( portSTACK_GROWTH &gt; 0 ) )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> taskCHECK_FOR_STACK_OVERFLOW()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int8_t</span> *pcEndOfStack = ( <span class="type">int8_t</span> * ) pxCurrentTCB-&gt;pxEndOfStack;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint8_t</span> ucExpectedStackBytes[] = &#123;tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE,</span><br><span class="line">tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE,</span><br><span class="line">tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE,</span><br><span class="line">tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE,</span><br><span class="line">tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE &#125;;</span><br><span class="line">pcEndOfStack -= <span class="keyword">sizeof</span>( ucExpectedStackBytes );</span><br><span class="line"><span class="comment">/* Has the extremity of the task stack ever been written over? */</span></span><br><span class="line"><span class="keyword">if</span>( <span class="built_in">memcmp</span>( ( <span class="type">void</span> * ) pcEndOfStack, ( <span class="type">void</span> * ) ucExpectedStackBytes, \</span><br><span class="line"><span class="keyword">sizeof</span>( ucExpectedStackBytes) ) != <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">vApplicationStackOverflowHook( ( TaskHandle_t ) pxCurrentTCB, pxCurrentTCB-&gt;pcTaskName );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="队列管理"><a href="#队列管理" class="headerlink" title="队列管理"></a>队列管理</h1><h2 id="队列基础知识"><a href="#队列基础知识" class="headerlink" title="队列基础知识"></a>队列基础知识</h2><ul><li><strong>FreeRTOS 中所有的通信与同步机制都是基于队列实现的</strong></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello Tadeo!</title>
      <link href="/2024/04/11/Hello/"/>
      <url>/2024/04/11/Hello/</url>
      
        <content type="html"><![CDATA[<h1 id="欢迎来到Tadeo的博客空间！"><a href="#欢迎来到Tadeo的博客空间！" class="headerlink" title="欢迎来到Tadeo的博客空间！"></a>欢迎来到Tadeo的博客空间！</h1><h1 id="2024-04-11-这是我开始记录博客的时间！"><a href="#2024-04-11-这是我开始记录博客的时间！" class="headerlink" title="2024.04.11 这是我开始记录博客的时间！"></a>2024.04.11 这是我开始记录博客的时间！</h1><h1 id="加油！坚持下去！"><a href="#加油！坚持下去！" class="headerlink" title="加油！坚持下去！"></a>加油！坚持下去！</h1>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
